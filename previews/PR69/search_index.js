var documenterSearchIndex = {"docs":
[{"location":"how_to_guides/intro_page/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"how_to_guides/intro_page/","page":"Examples","title":"Examples","text":"Tutorials to be created soon.","category":"page"},{"location":"api/internal/#Internal-API","page":"Internal API Reference","title":"Internal API","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Simulations.DispatchProblem\nResults.StorageAvailability","category":"page"},{"location":"api/internal/#PRASCore.Simulations.DispatchProblem","page":"Internal API Reference","title":"PRASCore.Simulations.DispatchProblem","text":"DispatchProblem(sys::SystemModel)\n\nCreate a min-cost flow problem for the multi-region max power delivery problem with generation and storage discharging in decreasing order of priority, and storage charging with excess capacity. Storage and GeneratorStorage devices within a region are represented individually on the network.\n\nThis involves injections/withdrawals at one node (regional capacity surplus/shortfall) for each modelled region, as well as two/three nodes associated with each Storage/GeneratorStorage device, and a supplementary \"slack\" node in the network that can absorb undispatched power or pass unserved energy or unused charging capability through to satisfy power balance constraints.\n\nFlows from the generation nodes are free, while flows to charging and from discharging nodes are costed or rewarded according to the time-to-discharge of the storage device, ensuring efficient coordination across units, while enforcing that storage is only discharged once generation capacity is exhausted (implying an operational strategy that prioritizes resource adequacy over economic arbitrage). This is based on the storage dispatch strategy of Evans, Tindemans, and Angeli, as outlined in \"Minimizing Unserved Energy Using Heterogenous Storage Units\" (IEEE Transactions on Power Systems, 2019).\n\nFlows to the charging node have an attenuated negative cost (reward), incentivizing immediate storage charging if generation and transmission allows it, while avoiding charging by discharging other storage (since that would incur an overall positive cost).\n\nFlows to the slack node (representing unused generation or storage discharge capacity) are free, but flows from the slack node to serve load incur the lost load penalty of 9999. Flows from the slack node in lieu of storage charging or discharging are free.\n\nFlows on transmission interfaces assume a hurdle rate of 1 to keep unserved energy close to the source of the shortage and eliminate loop flows. This has the side-effect of disincentivising wheeling power across multiple regions for charging purposes, however.\n\nNodes in the problem are ordered as:\n\nRegions generation surplus/shortfall (Regions order)\nStorage discharge capacity (Storage order)\nStorage charge capacity (Storage order)\nGenerationStorage inflow capacity (GeneratorStorage order)\nGenerationStorage discharge capacity (GeneratorStorage order)\nGenerationStorage grid injection (GeneratorStorage order)\nGenerationStorage charge capacity (GeneratorStorage order)\nSlack node\n\nEdges are ordered as:\n\nRegions demand unserved (Regions order)\nRegions generation unused (Regions order)\nInterfaces forward flow (Interfaces order)\nInterfaces reverse flow (Interfaces order)\nStorage discharge to grid (Storage order)\nStorage discharge unused (Storage order)\nStorage charge from grid (Storage order)\nStorage charge unused (Storage order)\nGenerationStorage discharge to grid (GeneratorStorage order)\nGenerationStorage discharge unused (GeneratorStorage order)\nGenerationStorage inflow to grid (GenerationStorage order)\nGenerationStorage total to grid (GeneratorStorage order)\nGenerationStorage charge from grid (GeneratorStorage order)\nGenerationStorage charge from inflow (GeneratorStorage order)\nGenerationStorage charge unused (GeneratorStorage order)\nGenerationStorage inflow unused (GeneratorStorage order)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PRASCore.Results.StorageAvailability","page":"Internal API Reference","title":"PRASCore.Results.StorageAvailability","text":"StorageAvailability\n\nThe StorageAvailability result specification reports the sample-level discrete availability of Storages, producing a StorageAvailabilityResult.\n\nA StorageAvailabilityResult can be indexed by storage device name and a timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\nstoravail, =\n    assess(sys, SequentialMonteCarlo(samples=10), StorageAvailability())\n\nsamples = storavail[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [SiennaPRASInterface, SiennaPRASInterface.PRASCore]\nPublic = false","category":"page"},{"location":"api/internal/#SiennaPRASInterface.HVDCLineTypes","page":"Internal API Reference","title":"SiennaPRASInterface.HVDCLineTypes","text":"Supported DC branch Types\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.OUTAGE_INFO_FILE","page":"Internal API Reference","title":"SiennaPRASInterface.OUTAGE_INFO_FILE","text":"DEFAULT outage data which is used when outage_flag is set to FALSE\n\nBased on ERCOT historical data\n\n\n\n\n\n","category":"constant"},{"location":"api/internal/#SiennaPRASInterface.TransformerTypes","page":"Internal API Reference","title":"SiennaPRASInterface.TransformerTypes","text":"Filtered Transformer Types\n\nThese transformers are not modeled as lines in PRAS.\n\n\n\n\n\n","category":"constant"},{"location":"api/internal/#SiennaPRASInterface.AbstractRAFormulation","page":"Internal API Reference","title":"SiennaPRASInterface.AbstractRAFormulation","text":"AbstractRAFormulation\n\nAbstract type for translating a Sienna object in PRAS. Multiple objects can use the same formulation.\n\nFormulations are also intended to contain information about their configuration such as time series names.\n\nPRAS formulation subtypes for specific PRAS types\n\nGeneratorPRAS\nStoragePRAS (abstract type)\nGeneratorStoragePRAS (abstract type)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.InterfacePRAS","page":"Internal API Reference","title":"SiennaPRASInterface.InterfacePRAS","text":"InterfacePRAS <: AbstractRAFormulation\n\nInterfacePRAS produces interface entries in PRAS.\n\nIf not supplied, then interfaces will be generated by Lines\n\nSubtypes must provide add_to_interface! function.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.LoadPRAS","page":"Internal API Reference","title":"SiennaPRASInterface.LoadPRAS","text":"LoadPRAS <: AbstractRAFormulation\n\nSee add_to_load_matrix for how the formulation is used to add load to regions.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.S2P_metadata","page":"Internal API Reference","title":"SiennaPRASInterface.S2P_metadata","text":"S2P_metadata\n\nStruct to store metadata for the Sienna to PRAS conversion\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.SPIOutageResult","page":"Internal API Reference","title":"SiennaPRASInterface.SPIOutageResult","text":"SPIOutageResult(; shortfall_samples, gen_availability, stor_availability, gen_stor_availability)\n\nArguments\n\nshortfall_samples::PRASCore.Results.ShortfallSamplesResult: Shortfall Sample Result\ngen_availability::PRASCore.Results.GeneratorAvailabilityResult: Generator Availability Result\nstor_availability::PRASCore.Results.StorageAvailabilityResult: Storage Availability Result\ngen_stor_availability::PRASCore.Results.GeneratorStorageAvailabilityResult: GeneratorStorage Availability Result\n\nSPIOutageResult is used to parse Tuple{Vararg{PRAS.PRASCore.Results.Result}} and add structure to it.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.outage_data","page":"Internal API Reference","title":"SiennaPRASInterface.outage_data","text":"outage_data\n\nStruct to store the outage information for a component.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#SiennaPRASInterface.add_asset_status!-Tuple{PowerSystems.System, SiennaPRASInterface.SPIOutageResult, RATemplate}","page":"Internal API Reference","title":"SiennaPRASInterface.add_asset_status!","text":"add_asset_status!(\n    sys::PowerSystems.System,\n    results::SiennaPRASInterface.SPIOutageResult,\n    template::RATemplate\n)\n\n\nAdd the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\nresults::T: SPIOutageResult\ntemplate::RATemplate: PRAS problem template\n\nReturns\n\n- PSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.add_default_data!","page":"Internal API Reference","title":"SiennaPRASInterface.add_default_data!","text":"Add default data to a system from OUTAGE_INFO_FILE (ERCOT data).\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#SiennaPRASInterface.add_to_interface!-Tuple{AreaInterchangeLimit, Vararg{Any, 4}}","page":"Internal API Reference","title":"SiennaPRASInterface.add_to_interface!","text":"add_to_interface!(\n    _::AreaInterchangeLimit,\n    interface,\n    s2p_meta,\n    forward_row,\n    backward_row\n) -> Any\n\n\nAdd flow limits of an Sienna interface to an existing PRAS interface\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.appliestodevice-Union{Tuple{T}, Tuple{D}, Tuple{DeviceRAModel{D}, Type{T}}} where {D, T}","page":"Internal API Reference","title":"SiennaPRASInterface.appliestodevice","text":"Check whether a DeviceRAModel applies to a given type\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.assign_to_gen_stor_matrices!-Tuple{HybridSystemPRAS, PowerSystems.Device, SiennaPRASInterface.S2P_metadata, Vararg{Any, 5}}","page":"Internal API Reference","title":"SiennaPRASInterface.assign_to_gen_stor_matrices!","text":"assign_to_gen_stor_matrices!(\n    formulation::HybridSystemPRAS,\n    g_s::PowerSystems.Device,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    charge_cap_array,\n    discharge_cap_array,\n    inflow_array,\n    energy_cap_array,\n    gridinj_cap_array\n) -> Any\n\n\nApply HybridSystem Formulation to fill in a row of a PRAS Matrix. Views should be passed in for all arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.assign_to_gen_stor_matrices!-Tuple{HydroEnergyReservoirPRAS, PowerSystems.Device, SiennaPRASInterface.S2P_metadata, Vararg{Any, 5}}","page":"Internal API Reference","title":"SiennaPRASInterface.assign_to_gen_stor_matrices!","text":"assign_to_gen_stor_matrices!(\n    formulation::HydroEnergyReservoirPRAS,\n    g_s::PowerSystems.Device,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    charge_cap_array,\n    discharge_cap_array,\n    inflow_array,\n    energy_cap_array,\n    gridinj_cap_array\n) -> Any\n\n\nApply HydroEnergyReservoir Formulation to fill in a row of a PRAS Matrix. Views should be passed in for all arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.assign_to_line_matrices!-Tuple{LinePRAS, PowerSystems.Branch, SiennaPRASInterface.S2P_metadata, Any, Any}","page":"Internal API Reference","title":"SiennaPRASInterface.assign_to_line_matrices!","text":"assign_to_line_matrices!(\n    _::LinePRAS,\n    line::PowerSystems.Branch,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    forward_cap,\n    backward_cap\n) -> Any\n\n\nApply LinePRAS to create PRAS matrices for lines. Views should be passed in.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.build_component_to_formulation-Tuple{Type{GeneratorPRAS}, PowerSystems.System, Array{DeviceRAModel}}","page":"Internal API Reference","title":"SiennaPRASInterface.build_component_to_formulation","text":"build_component_to_formulation(_, sys, device_models)\n\n\nConstructs a dictionary from Sienna Devices to GeneratorPRAS formulation objects\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.build_component_to_formulation-Union{Tuple{B}, Tuple{Type{B}, PowerSystems.System, Array{DeviceRAModel}}} where B<:SiennaPRASInterface.AbstractRAFormulation","page":"Internal API Reference","title":"SiennaPRASInterface.build_component_to_formulation","text":"build_component_to_formulation(_, sys, device_models)\n\n\nConstructs a dictionary from Sienna Devices to formulation objects\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.build_interfaces_from_lines-Tuple{Matrix{Int64}, Matrix{Int64}, Vector{Tuple{Int64, Int64}}, Vector{UnitRange{Int64}}, SiennaPRASInterface.S2P_metadata}","page":"Internal API Reference","title":"SiennaPRASInterface.build_interfaces_from_lines","text":"build_interfaces_from_lines(\n    line_forward_cap::Matrix{Int64},\n    line_backward_cap::Matrix{Int64},\n    interface_reg_idxs::Vector{Tuple{Int64, Int64}},\n    interface_line_idxs::Vector{UnitRange{Int64}},\n    s2p_meta::SiennaPRASInterface.S2P_metadata\n) -> Interfaces{_A, MW} where _A\n\n\nCreate PRAS interfaces from PRAS Lines\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.check_file-Tuple{String}","page":"Internal API Reference","title":"SiennaPRASInterface.check_file","text":"check_file(loc::String)\n\nCheck if the file exists and is openable.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_aggregation_function-Tuple{PowerSystems.Area}","page":"Internal API Reference","title":"SiennaPRASInterface.get_aggregation_function","text":"get_aggregation_function(::PSY.Area)\n\nGet getter function based on PSY.AggregationTopology\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_available_components-Union{Tuple{D}, Tuple{DeviceRAModel{D}, PowerSystems.System}} where D<:PowerSystems.Device","page":"Internal API Reference","title":"SiennaPRASInterface.get_available_components","text":"Uses a PRAS device model to find all components matching it in a system.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_available_components_in_aggregation_topology-Tuple{Type{<:PowerSystems.StaticInjection}, PowerSystems.System, PowerSystems.AggregationTopology}","page":"Internal API Reference","title":"SiennaPRASInterface.get_available_components_in_aggregation_topology","text":"get_available_components_in_aggregation_topology(\n    type::Type{<:PSY.StaticInjection},\n    sys::PSY.System,\n    region::PSY.AggregationTopology,\n)\n\nGet available components in the AggregationTopology region of the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_device_ramodel-Union{Tuple{Type{T}}, Tuple{T}} where T<:PRASCore.Results.GeneratorAvailabilityResult","page":"Internal API Reference","title":"SiennaPRASInterface.get_device_ramodel","text":"Get DeviceRAModel for PRAS AbstractAvailabilityResult\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_device_ramodel-Union{Tuple{Type{T}}, Tuple{T}} where T<:PRASCore.Results.GeneratorStorageAvailabilityResult","page":"Internal API Reference","title":"SiennaPRASInterface.get_device_ramodel","text":"Get DeviceRAModel for PRAS AbstractAvailabilityResult\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_device_ramodel-Union{Tuple{Type{T}}, Tuple{T}} where T<:PRASCore.Results.StorageAvailabilityResult","page":"Internal API Reference","title":"SiennaPRASInterface.get_device_ramodel","text":"Get DeviceRAModel for PRAS AbstractAvailabilityResult\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_formulation-Tuple{DeviceRAModel}","page":"Internal API Reference","title":"SiennaPRASInterface.get_formulation","text":"Get formulation from a DeviceRAModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_gen_storage_region_indices-Tuple{PowerSystems.System, Any, Dict{PowerSystems.Device, GeneratorStoragePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_gen_storage_region_indices","text":"get_gen_storage_region_indices(\n    sys::PowerSystems.System,\n    regions,\n    component_to_formulation::Dict{PowerSystems.Device, GeneratorStoragePRAS}\n) -> Tuple{Any, Any}\n\n\nExtract components with a generator storage formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_generator_category-Tuple{PowerSystems.StaticInjection}","page":"Internal API Reference","title":"SiennaPRASInterface.get_generator_category","text":"get_generator_category(gen::StaticInjection)\n\nGet the category of the generator.\n\nArguments\n\ngen::StaticInjection: Generator\n\nReturns\n\nString: Category of the generator\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_generator_region_indices-Tuple{PowerSystems.System, SiennaPRASInterface.S2P_metadata, Any, Dict{String, Dict{PowerSystems.Device, GeneratorPRAS}}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_generator_region_indices","text":"get_generator_region_indices(\n    sys::PowerSystems.System,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    regions,\n    component_to_formulation::Dict{String, Dict{PowerSystems.Device, GeneratorPRAS}}\n) -> Tuple{Any, Any, Dict{String, Vector{PowerSystems.Device}}}\n\n\nExtraction of generators using formulation dictionary to create a list of generators and appropriate indices for PRAS. Note that objects with 0 max active power are excluded.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_generators_from_formulation_mapping-Union{Tuple{Dict{PowerSystems.Device, B}}, Tuple{B}} where B<:SiennaPRASInterface.AbstractRAFormulation","page":"Internal API Reference","title":"SiennaPRASInterface.get_generators_from_formulation_mapping","text":"get_generators_from_formulation_mapping(Dict{PSY.Device, B}) where {B <: AbstractRAFormulation}\n\nGet generators based on formulation to add availability data\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_inflow-Tuple{HydroEnergyReservoirPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_inflow","text":"Get inflow time series name\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_lump_renewable_generation-Tuple{GeneratorPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_lump_renewable_generation","text":"Get whether renewable generation is lumped to regions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_max_active_power-Tuple{GeneratorPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_max_active_power","text":"Get max active power time series name\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_max_active_power-Tuple{HybridSystemPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_max_active_power","text":"Get max active power time series name\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_max_active_power-Tuple{HydroEnergyReservoirPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_max_active_power","text":"Get max active power time series name\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_pras_array_from_timeseries-Tuple{PowerSystems.Device, Any}","page":"Internal API Reference","title":"SiennaPRASInterface.get_pras_array_from_timeseries","text":"Turn a time series into an Array of floored ints\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_region_loads-Tuple{SiennaPRASInterface.S2P_metadata, Any, Dict{PowerSystems.Device, SiennaPRASInterface.LoadPRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_region_loads","text":"get_region_loads(\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    regions,\n    loads_to_formulations::Dict{PowerSystems.Device, SiennaPRASInterface.LoadPRAS}\n) -> Matrix{Int64}\n\n\nExtract region load as a matrix of Int64 values.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_sorted_lines-Tuple{Vector{PowerSystems.Branch}, Vector{String}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_sorted_lines","text":"get_sorted_lines(lines::Vector{PSY.Branch}, region_names::Vector{String})\n\nGet sorted lines, interface region indices, and interface line indices.\n\nArguments\n\nlines::Vector{PSY.Branch}: Lines\nregion_names::Vector{String}: Region names\n\nReturns\n\nsorted_lines::Vector{PSY.Branch}: Sorted lines\ninterface_reg_idxs::Vector{Tuple{Int, Int}}: Interface region indices\ninterface_line_idxs::Vector{UnitRange{Int}}: Interface line indices\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_sorted_region_tuples-Tuple{Vector{PowerSystems.Branch}, Vector{String}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_sorted_region_tuples","text":"get_sorted_region_tuples(lines::Vector{PSY.Branch}, region_names::Vector{String})\n\nGet sorted (regfrom, regto) tuples of inter-regional lines.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_storage_capacity-Tuple{HydroEnergyReservoirPRAS}","page":"Internal API Reference","title":"SiennaPRASInterface.get_storage_capacity","text":"Get storage capacity time series name\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_storage_region_indices-Tuple{PowerSystems.System, SiennaPRASInterface.S2P_metadata, Any, Dict{PowerSystems.Device, StoragePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.get_storage_region_indices","text":"get_storage_region_indices(\n    sys::PowerSystems.System,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    regions,\n    component_to_formulation::Dict{PowerSystems.Device, StoragePRAS}\n) -> Tuple{Any, Any}\n\n\nExtraction of storage devices using formulation dictionary to create a list of storage devices and appropriate indices for PRAS.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.get_timestamps-Union{Tuple{TIMEPERIOD}, Tuple{Dates.DateTime, TIMEPERIOD, Int64, Int64}} where TIMEPERIOD<:Dates.TimePeriod","page":"Internal API Reference","title":"SiennaPRASInterface.get_timestamps","text":"get_timestamps(initial_time, resolution, steps, horizon)\n\nReturn a vector of timestamps starting from initial_time with resolution and steps for horizon steps\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.initialize_availability!-Tuple{Random.AbstractRNG, Vector{Bool}, Vector{Int64}, Vector{PowerSystems.Generator}, Int64}","page":"Internal API Reference","title":"SiennaPRASInterface.initialize_availability!","text":"initializeavailability!(rng, availability, nexttransition, devices, tlast)\n\nArguments\n\nrng::Random.AbstractRNG: Random number generator\navailability::Vector{Bool}: Vector of availability status\nnexttransition::Vector{Int}: Vector of next transition time\ndevices::Vector{PSY.Generator}: Vector of devices with outage SupplementalAttributes\nt_last::Int: Last time step\n\nReturns\n\nModifies input arguments and rereturns\n\navailability::Vector{Bool}: Vector of availability status\nnexttransition::Vector{Int}: Vector of next transition time\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.line_rating-Tuple{PowerSystems.Branch}","page":"Internal API Reference","title":"SiennaPRASInterface.line_rating","text":"line_rating(line::Branch)\n\nGet the line rating.\n\nArguments\n\nline::Branch: Line\n\nReturns\n\nTuple{forward_capacity::Float64, backward_capacity::Float64}: Line rating\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.line_type-Tuple{PowerSystems.Branch}","page":"Internal API Reference","title":"SiennaPRASInterface.line_type","text":"line_type(line::Branch)\n\nGet the line type.\n\nArguments\n\nline::Branch: Line\n\nReturns\n\nString: Line type\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.process_generators-Tuple{Array{PowerSystems.Device}, SiennaPRASInterface.S2P_metadata, Dict{String, Dict{PowerSystems.Device, GeneratorPRAS}}, Dict{String, Vector{PowerSystems.Device}}}","page":"Internal API Reference","title":"SiennaPRASInterface.process_generators","text":"process_generators(\n    gen::Array{PowerSystems.Device},\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    component_to_formulation::Dict{String, Dict{PowerSystems.Device, GeneratorPRAS}},\n    lumped_mapping::Dict{String, Vector{PowerSystems.Device}}\n) -> Generators{_A, _B, T, MW} where {_A, _B, T<:Period}\n\n\nApply GeneratorPRAS to process all generators objects into rows in PRAS matrices:\n\nCapacity, λ, μ\n\nNegative max active power will translate into zeros for time series data.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.process_genstorage-Tuple{Array{PowerSystems.Device}, SiennaPRASInterface.S2P_metadata, Dict{PowerSystems.Device, GeneratorStoragePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.process_genstorage","text":"process_genstorage(\n    gen_stor::Array{PowerSystems.Device},\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    component_to_formulation::Dict{PowerSystems.Device, GeneratorStoragePRAS}\n) -> GeneratorStorages{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\n\n\nApply GeneratorStoragePRAS to create PRAS matrices for generator storage\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.process_interfaces-Tuple{Vector{Tuple{Int64, Int64}}, Any, SiennaPRASInterface.S2P_metadata, Dict{PowerSystems.Device, SiennaPRASInterface.InterfacePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.process_interfaces","text":"process_interfaces(\n    interface_reg_idxs::Vector{Tuple{Int64, Int64}},\n    regions,\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    interfaces_to_formulation::Dict{PowerSystems.Device, SiennaPRASInterface.InterfacePRAS}\n) -> Interfaces{_A, MW} where _A\n\n\nProcess interfaces using a formulation dictionary to create PRAS matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.process_lines-Tuple{Vector{PowerSystems.Branch}, SiennaPRASInterface.S2P_metadata, Dict{PowerSystems.Device, LinePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.process_lines","text":"process_lines(\n    sorted_lines::Vector{PowerSystems.Branch},\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    lines_to_formulation::Dict{PowerSystems.Device, LinePRAS}\n) -> Lines{_A, _B, T, MW} where {_A, _B, T<:Period}\n\n\nCreate PRAS from sorted lines and formulations.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.process_storage-Tuple{Array{PowerSystems.Device}, SiennaPRASInterface.S2P_metadata, Dict{PowerSystems.Device, StoragePRAS}}","page":"Internal API Reference","title":"SiennaPRASInterface.process_storage","text":"process_storage(\n    stor::Array{PowerSystems.Device},\n    s2p_meta::SiennaPRASInterface.S2P_metadata,\n    component_to_formulation::Dict{PowerSystems.Device, StoragePRAS}\n) -> Storages{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\n\n\nApply StoragePRAS to process all storage objects\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.rate_to_probability-Tuple{Float64, Int64}","page":"Internal API Reference","title":"SiennaPRASInterface.rate_to_probability","text":"rate_to_probability(for_gen::Float64, mttr::Int64)\n\nConverts the forced outage rate and mean time to repair to the λ and μ parameters\n\nArguments\n\nfor_gen::Float64: Forced outage rate [1/T]\nmttr::Int64: Mean time to repair [T]\n\nReturns\n\nλ::Float64: Transition probability from online to offline [1/T]\nμ::Float64: Transition rate from offline to online [1/T]\n\nReference\n\nhttps://core.ac.uk/download/pdf/13643059.pdf\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.runchecks-Tuple{String}","page":"Internal API Reference","title":"SiennaPRASInterface.runchecks","text":"runchecks(sys_location::String)\n\nCheck if the System JSON file is serialized as well as other files required.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#SiennaPRASInterface.update_availability!-Tuple{Random.AbstractRNG, Vector{Bool}, Vector{Int64}, Vector{PowerSystems.Generator}, Int64, Int64}","page":"Internal API Reference","title":"SiennaPRASInterface.update_availability!","text":"update_availability!(rng, availability, nexttransition, devices, t_now, t_last)\n\nReturn availability and next transition with new randomness\n\n\n\n\n\n","category":"method"},{"location":"explanations/default_outage_values/#Default-values-used-for-outage-statistics","page":"Default outage values","title":"Default values used for outage statistics","text":"","category":"section"},{"location":"explanations/default_outage_values/","page":"Default outage values","title":"Default outage values","text":"When a system does not contain any GeometricDistributionForcedOutage supplemental attributes attached to any components, then the outage rates default to a set of defaults defined in the Default Outage Rates CSV based off of rates in ERCOT.","category":"page"},{"location":"explanations/default_outage_values/","page":"Default outage values","title":"Default outage values","text":"For any remaining components not captured by the CSV defaults, such as lines, renewables, and storage, the outage rates are 0 and will never fail.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#How-do-I-add-outage-data-to-Sienna?","page":"How do I add outage data?","title":"How do I add outage data to Sienna?","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"You can attach outage data to PowerSystems Components by using the supplemental attribute GeometricDistributionForcedOutage.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#Step-1-:-Parse-your-outage-data-into-Sienna","page":"How do I add outage data?","title":"Step 1 : Parse your outage data into Sienna","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"SiennaPRASInterface.jl uses outage information in the form of independent mean_time_to_recovery in units of hours and outage_transition_probability in probability of outage per hour. A simple Markov model models the transitions between out and active using these parameters.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"We support data either being fixed and specified in the GeometricDistributionForcedOutage object or attached as time-series to the GeometricDistributionForcedOutage struct.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#Creating-a-GeometricDistributionForcedOutage-from-fixed-data","page":"How do I add outage data?","title":"Creating a GeometricDistributionForcedOutage from fixed data","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"using PowerSystems\nimport PowerSystemCaseBuilder # hide\nconst PSCB = PowerSystemCaseBuilder # hide\nsys = PSCB.build_system(PSCB.PSISystems, \"RTS_GMLC_DA_sys\") # hide\nset_units_base_system!(sys, \"natural_units\") # hide\n\ntransition_data = GeometricDistributionForcedOutage(;\n    mean_time_to_recovery=10,  # Units of hours\n    outage_transition_probability=0.005,  # Probability for outage per hour\n)\ntransition_data","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#Step-2-:-Attaching-Data-to-Components","page":"How do I add outage data?","title":"Step 2 : Attaching Data to Components","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"Once you have a GeometricDistributionForcedOutage object, then you can add it to any components with that data:","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"component = get_component(Generator, sys, \"101_CT_1\")\nadd_supplemental_attribute!(sys, component, transition_data)\ncomponent","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#Step-3-(Optional)-:-Adding-time-series-data-to-GeometricDistributionForcedOutage-from-time-series-data","page":"How do I add outage data?","title":"Step 3 (Optional) : Adding time-series data to GeometricDistributionForcedOutage from time series data","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"Time series should be attached to a GeometricDistributionForcedOutage object under the keys recovery_probability (1/mean_time_to_recovery) and outage_probability.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"See the Sienna time-series documentation on working with time-series.","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"using Dates\nusing TimeSeries\n\noutage_probability = [0.1, 0.1, 0.2, 0.3, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.4]\nrecovery_probability = [0.1, 0.1, 0.2, 0.3, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.4]\n\n# Your resolution and length must match the other SingleTimeSeries in your System.\nresolution = Dates.Minute(5)\ntimestamps = range(DateTime(\"2020-01-01T08:00:00\"); step=resolution, length=8784)\noutage_timearray = TimeArray(timestamps, repeat(outage_probability, inner=div(8784, 12)))\noutage_time_series = SingleTimeSeries(; name=\"outage_probability\", data=outage_timearray)\n\nrecovery_timearray =\n    TimeArray(timestamps, repeat(recovery_probability, inner=div(8784, 12)))\nrecovery_time_series =\n    SingleTimeSeries(; name=\"recovery_probability\", data=recovery_timearray)\n\n# Here we assume you have a system named sys\nadd_time_series!(sys, transition_data, outage_time_series)\nadd_time_series!(sys, transition_data, recovery_time_series)\ntransition_data","category":"page"},{"location":"how_to_guides/how_do_i_add_outage_data/#Step-4-:-Run-simulations-and-verify-result","page":"How do I add outage data?","title":"Step 4 : Run simulations and verify result","text":"","category":"section"},{"location":"how_to_guides/how_do_i_add_outage_data/","page":"How do I add outage data?","title":"How do I add outage data?","text":"using SiennaPRASInterface\nmethod = SequentialMonteCarlo(samples=10, seed=1)\nshortfalls, = assess(sys, PowerSystems.Area, method, Shortfall())\neue = EUE(shortfalls)","category":"page"},{"location":"#SiennaPRASInterface.jl","page":"Welcome Page","title":"SiennaPRASInterface.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = SiennaPRASInterface","category":"page"},{"location":"#About","page":"Welcome Page","title":"About","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"SiennaPRASInterface.jl is a Julia package that provides an interface to PRAS.jl from Sienna's PowerSystem.jl's System data model.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The Probabilistic Resource Adequacy Suite (PRAS) analyzes the resource adequacy of a bulk power system using Monte Carlo methods.","category":"page"},{"location":"#Getting-Started","page":"Welcome Page","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"To use SiennaPRASInterface.jl, you first need a System from PowerSystems.jl","category":"page"},{"location":"#1.-Install","page":"Welcome Page","title":"1. Install","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add SiennaPRASInterface","category":"page"},{"location":"#2.-Add-Data","page":"Welcome Page","title":"2. Add Data","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Add outage information to generators using the supplemental attribute GeometricDistributionForcedOutage.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"using PowerSystems\ntransition_data = GeometricDistributionForcedOutage(;\n    mean_time_to_recovery=10,  # Units of hours\n    outage_transition_probability=0.005,  # Probability for outage per hour\n)\ncomponent = get_component(Generator, sys, \"test_generator\")\nadd_supplemental_attribute!(sys, component, transition_data)","category":"page"},{"location":"#3.-Calculate-Shortfalls-and-Expected-Unserved-Energy-on-System","page":"Welcome Page","title":"3. Calculate Shortfalls and Expected Unserved Energy on System","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"using SiennaPRASInterface\nsequential_monte_carlo = SequentialMonteCarlo(samples=10_000, seed=1)\nshortfalls, = assess(sys, PowerSystems.Area, sequential_monte_carlo, Shortfall())\neue = EUE(shortfalls)","category":"page"},{"location":"#Documentation","page":"Welcome Page","title":"Documentation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PRAS Documentation","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Pages = [\"api/public.md\", \"tutorials\"]\nDepth = 2","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"SiennaPRASInterface has been developed as part of the Transmission Planning Tools Maintenance project at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL) funded by DOE Grid Deployment Office (GDO).","category":"page"},{"location":"api/public/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [SiennaPRASInterface]\nPrivate = false","category":"page"},{"location":"api/public/#SiennaPRASInterface.SiennaPRASInterface","page":"Public API Reference","title":"SiennaPRASInterface.SiennaPRASInterface","text":"PowerSystems Interface for Probabilistic Resource Adequacy Studies (PRAS)\n\nKey Functions\n\ngenerate_pras_system: convert PSY to PRAS model\nassess: assess PRAS model\n\nKey PRAS Types\n\nSystemModel: PRAS data structure\nSequentialMonteCarlo: method for PRAS analysis\nShortfall: PRAS metric for missing generation\nLOLE: PRAS metric for loss of load expectation\nEUE: PRAS metric for energy unserved expectation\n\n\n\n\n\n","category":"module"},{"location":"api/public/#SiennaPRASInterface.AreaInterchangeLimit","page":"Public API Reference","title":"SiennaPRASInterface.AreaInterchangeLimit","text":"AreaInterchangeLimit <: InterfacePRAS\n\nAreaInterchangeLimit produces interfaces from AreaInterchange objects\n\nEach line must have a corresponding AreaInterchange. All AreaInterchange objects will be consolidated for each pair of directly connected regions.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.DeviceRAModel","page":"Public API Reference","title":"SiennaPRASInterface.DeviceRAModel","text":"DeviceRAModel{D <: PSY.Device, B <: AbstractRAFormulation}\n\nArguments\n\nD <: PSY.Device: Device type\nformulation::SiennaPRASInterface.AbstractRAFormulation: Formulation containing configuration\n\nA DeviceRAModel, like a DeviceModel in PowerSimulations, assigns a type of Component to a specific formulation. Unlike Sienna, we put configuration information in the formulation itself.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.DeviceRAModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D}, Type{B}}} where {D<:PowerSystems.Device, B<:SiennaPRASInterface.AbstractRAFormulation}","page":"Public API Reference","title":"SiennaPRASInterface.DeviceRAModel","text":"DeviceRAModel(\n    ::Type{D<:PowerSystems.Device},\n    ::Type{B<:SiennaPRASInterface.AbstractRAFormulation};\n    time_series_names,\n    kwargs...\n) -> DeviceRAModel\n\n\nArguments\n\n::Type{D}: Device type\n::Type{B}: Formulation type\ntime_series_names::Dict{Symbol, String}: Mapping of time series Symbol to names\nkwargs...: Additional arguments to pass to the formulation constructor\n\nKeyword arguments in DeviceRAModel are passed to the formulation constructor.\n\nYou may also pass a time_series_names Dict to map time series Symbol to names.\n\nExample\n\nDeviceRAModel(\n    PSY.Generator,\n    GeneratorPRAS(max_active_power=\"max_active_power\"),\n)\n\nDeviceRAModel(\n    PSY.HydroEnergyReservoir,\n    HydroEnergyReservoirPRAS;\n    max_active_power=\"max_active_power\",\n    inflow=\"inflow\",\n    storage_capacity=\"storage_capacity\",\n)\n\nDeviceRAModel(\n    PSY.HybridSystem,\n    HybridSystemPRAS;\n    time_series_names=Dict(:max_active_power=\"max_active_power\"),\n)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.EnergyReservoirLossless","page":"Public API Reference","title":"SiennaPRASInterface.EnergyReservoirLossless","text":"EnergyReservoirLossless <: StoragePRAS\n\nEnergyReservoirLossless is a storage formulation that does not lose energy.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.GeneratorPRAS","page":"Public API Reference","title":"SiennaPRASInterface.GeneratorPRAS","text":"GeneratorPRAS(; max_active_power, lump_renewable_generation) <: AbstractRAFormulation\n\nArguments\n\nmax_active_power::String: Name of time series to use for max active power\nlump_renewable_generation::Bool: Whether to lump renewable generation to regions\n\nGeneratorPRAS produces generator entries in PRAS.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.GeneratorStoragePRAS","page":"Public API Reference","title":"SiennaPRASInterface.GeneratorStoragePRAS","text":"GeneratorStoragePRAS <: AbstractRAFormulation\n\nObjects in Sienna that behave like generator and storage are mapped to generatorstorage in PRAS.\n\nTo add a generator storage formulation, you must also add a assign_to_gen_stor_matrices! function.\n\nHybridSystemPRAS\nHydroEnergyReservoirPRAS\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.HybridSystemPRAS","page":"Public API Reference","title":"SiennaPRASInterface.HybridSystemPRAS","text":"HybridSystemPRAS(; max_active_power) <: GeneratorStoragePRAS\n\nArguments\n\nmax_active_power::String: Name of time series to use for max active power\n\nHybridSystemPRAS produces generatorstorage entries in PRAS.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.HydroEnergyReservoirPRAS","page":"Public API Reference","title":"SiennaPRASInterface.HydroEnergyReservoirPRAS","text":"HydroEnergyReservoirPRAS <: GeneratorStoragePRAS\n\nArguments\n\nmax_active_power::String: Name of time series to use for max active power\ninflow::String: Name of time series to use for inflow\nstorage_capacity::String: Name of time series to use for storage capacity\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.LinePRAS","page":"Public API Reference","title":"SiennaPRASInterface.LinePRAS","text":"LinePRAS <: AbstractRAFormulation\n\nLinePRAS produces line entries in PRAS.\n\nSee assign_to_line_matrices! for the formulation handling. Any subtypes must implement this.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.RATemplate","page":"Public API Reference","title":"SiennaPRASInterface.RATemplate","text":"Arguments\n\naggregation::Type{T} where T<:PowerSystems.AggregationTopology: Level of aggregation to use for PRAS regions\ndevice_models::Array{DeviceRAModel}: DeviceRAModels to translate components into PRAS\n\nThe RATemplate contains all configuration necessary for building a PRAS Simulation from a PowerSystems.jl System.\n\nSince PRAS is an area-based model, we provide a level of aggregation to apply.\n\nPRAS models are processed in reverse order, with later models taking precedence.\n\nExample\n\ntemplate = RATemplate(\n    PSY.Area,\n    [\n        DeviceRAModel(\n            PSY.Generator,\n            GeneratorPRAS(max_active_power=\"max_active_power\"),\n        ),\n        DeviceRAModel(\n            PSY.HydroEnergyReservoir,\n            HydroEnergyReservoirPRAS(\n                max_active_power=\"max_active_power\",\n                inflow=\"inflow\",\n                storage_capacity=\"storage_capacity\",\n            ),\n        ),\n    ],\n)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.StaticLoadPRAS","page":"Public API Reference","title":"SiennaPRASInterface.StaticLoadPRAS","text":"StaticLoadPRAS <: LoadPRAS\n\nArguments\n\nmax_active_power::String: Name of time series to use for max active power\n\n\n\n\n\n","category":"type"},{"location":"api/public/#SiennaPRASInterface.StoragePRAS","page":"Public API Reference","title":"SiennaPRASInterface.StoragePRAS","text":"StoragePRAS <: AbstractRAFormulation\n\nObjects in Sienna that behave like storage are mapped to storage in PRAS.\n\nSubtypes must provide assign_to_stor_matrices! function.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Simulations.assess-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}","page":"Public API Reference","title":"PRASCore.Simulations.assess","text":"assess(\n    sys::PowerSystems.System,\n    template::RATemplate,\n    method::SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...\n) -> Any\n\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\ntemplate::RATemplate: PRAS problem template\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PRASCore.Simulations.assess-Tuple{PowerSystems.System, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}","page":"Public API Reference","title":"PRASCore.Simulations.assess","text":"assess(\n    sys::PowerSystems.System,\n    method::SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...\n) -> Any\n\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nUses default template with Area level aggregation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PRASCore.Simulations.assess-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}} where AT<:PowerSystems.AggregationTopology","page":"Public API Reference","title":"PRASCore.Simulations.assess","text":"assess(\n    sys::PSY.System,\n    aggregation::Type{AT},\n    method::PRASCore.SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...,\n) where {AT <: PSY.AggregationTopology}\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\naggregation::Type{AT}: Aggregation topology to use in translating to PRAS\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo}","page":"Public API Reference","title":"SiennaPRASInterface.generate_outage_profile!","text":"generate_outage_profile!(\n    sys::PowerSystems.System,\n    template::RATemplate,\n    method::SequentialMonteCarlo\n) -> PowerSystems.System\n\n\nAnalyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\ntemplate::RATemplate: PRAS problem template\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\n\nReturns\n\nPSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, SequentialMonteCarlo}","page":"Public API Reference","title":"SiennaPRASInterface.generate_outage_profile!","text":"generate_outage_profile!(\n    sys::PowerSystems.System,\n    method::SequentialMonteCarlo\n) -> PowerSystems.System\n\n\nAnalyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.\n\nUses default template with PSY.Area AggregationTopology.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\n\nReturns\n\n- PSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.generate_outage_profile!-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo}} where AT<:PowerSystems.AggregationTopology","page":"Public API Reference","title":"SiennaPRASInterface.generate_outage_profile!","text":"generate_outage_profile!(\n    sys::PSY.System,\n    aggregation::Type{AT},\n    method::PRASCore.SequentialMonteCarlo,\n) where {AT <: PSY.AggregationTopology, RM <: PRASCore.Results.ReliabilityMetric}\n\nAnalyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\naggregation::Type{AT}: Aggregation topology to use in translating to PRAS\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\n\nReturns\n\nPSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.generate_pras_system","page":"Public API Reference","title":"SiennaPRASInterface.generate_pras_system","text":"generate_pras_system(\n    sys::PowerSystems.System,\n    template::RATemplate\n) -> SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\ngenerate_pras_system(\n    sys::PowerSystems.System,\n    template::RATemplate,\n    export_location::Union{Nothing, String}\n) -> SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\n\n\nUse a RATemplate to create a PRAS system from a Sienna system.\n\nArguments\n\nsys::PSY.System: Sienna PowerSystems System\ntemplate::RATemplate: RATemplate\nexport_location::Union{Nothing, String}: Export location for PRAS SystemModel\n\nReturns\n\nPRASCore.SystemModel: PRAS SystemModel\n\nExamples\n\ngenerate_pras_system(sys, template)\n\nNote that the original system will only be set to NATURAL_UNITS.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}}, Tuple{PowerSystems.System, Type{AT}, Bool}, Tuple{PowerSystems.System, Type{AT}, Bool, Union{Nothing, String}}} where AT<:PowerSystems.AggregationTopology","page":"Public API Reference","title":"SiennaPRASInterface.generate_pras_system","text":"generate_pras_system(\n    sys::PowerSystems.System,\n    aggregation::Type{AT<:PowerSystems.AggregationTopology}\n) -> SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\ngenerate_pras_system(\n    sys::PowerSystems.System,\n    aggregation::Type{AT<:PowerSystems.AggregationTopology},\n    lump_region_renewable_gens::Bool\n) -> SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\ngenerate_pras_system(\n    sys::PowerSystems.System,\n    aggregation::Type{AT<:PowerSystems.AggregationTopology},\n    lump_region_renewable_gens::Bool,\n    export_location::Union{Nothing, String}\n) -> SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T<:Period}\n\n\nSienna/Data PowerSystems.jl System is the input and an object of PRAS SystemModel is returned. ...\n\nArguments\n\nsys::PSY.System: Sienna/Data PowerSystems.jl System\naggregation<:PSY.AggregationTopology: \"PSY.Area\" (or) \"PSY.LoadZone\" {Optional}\nlump_region_renewable_gens::Bool: Whether to lumps PV and Wind generators in a region because usually these generators don't have FOR data {Optional}\nexport_location::String: Export location of the .pras file ...\n\nReturns\n\n- `PRASCore.SystemModel`: PRAS SystemModel object\n\nExamples\n\njulia> generate_pras_system(psy_sys, PSY.Area)\nPRAS SystemModel\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{String, Type{AT}}, Tuple{String, Type{AT}, Any}, Tuple{String, Type{AT}, Any, Union{Nothing, String}}} where AT<:PowerSystems.AggregationTopology","page":"Public API Reference","title":"SiennaPRASInterface.generate_pras_system","text":"generate_pras_system(sys_location::String, aggregation; kwargs...)\n\nGenerate a PRAS SystemModel from a Sienna/Data PowerSystems System JSON file.\n\nArguments\n\nsys_location::String: Location of the Sienna/Data PowerSystems System JSON file\naggregation::Type{AT}: Aggregation topology type\nlump_region_renewable_gens::Bool: Lumping of region renewable generators\nexport_location::Union{Nothing, String}: Export location of the .pras file\n\nReturns\n\nPRASCore.SystemModel: PRAS SystemModel\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.make_generator_outage_draws!-Union{Tuple{PowerSystems.System}, Tuple{TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64, Int64}} where TIMEPERIOD<:Dates.TimePeriod","page":"Public API Reference","title":"SiennaPRASInterface.make_generator_outage_draws!","text":"make_generator_outage_draws!(\n    sys,\n    initial_time::Dates.DateTime=nothing,\n    resolution::TIMEPERIOD=nothing,\n    steps::Int=nothing,\n    horizon::Int=nothing,\n) where {TIMEPERIOD <: Dates.TimePeriod}\n\nAdds availability time series to the generators in the system.\n\nMain function to make generator outage draws.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.set_device_model!-Union{Tuple{B}, Tuple{D}, Tuple{RATemplate, Type{D}, Type{B}}} where {D<:PowerSystems.Device, B<:SiennaPRASInterface.AbstractRAFormulation}","page":"Public API Reference","title":"SiennaPRASInterface.set_device_model!","text":"set_device_model!(\n    template::RATemplate,\n    _::Type{D<:PowerSystems.Device},\n    _::Type{B<:SiennaPRASInterface.AbstractRAFormulation}\n) -> Vector{DeviceRAModel}\n\n\nArguments\n\ntemplate::RATemplate: Template to add device model to\n::Type{D}: Device type\n::Type{B}: Formulation type\n\nAdds a device model to a RATemplate by passing the type to a constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#SiennaPRASInterface.set_device_model!-Union{Tuple{D}, Tuple{RATemplate, DeviceRAModel{D}}} where D","page":"Public API Reference","title":"SiennaPRASInterface.set_device_model!","text":"set_device_model!(\n    template::RATemplate,\n    device_model::DeviceRAModel{D}\n) -> Vector{DeviceRAModel}\n\n\nArguments\n\ntemplate::RATemplate: Template to add device model to\ndevice_model::DeviceRAModel{D}: Device model to add\n\nAdd a device model to a RATemplate. If an existing model already applies to the given device type, then a warning is issued. However, newer models will take precedence.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PRAS-Documentation","page":"Public API Reference","title":"PRAS Documentation","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"SystemModel\nassess\nSequentialMonteCarlo\nShortfall\nSurplus\nFlow\nUtilization\nStorageEnergy\nGeneratorStorageEnergy\nLOLE\nEUE\nShortfallSamples\nSurplusSamples\nFlowSamples\nUtilizationSamples\nStorageEnergySamples\nGeneratorStorageEnergySamples\nGeneratorAvailability\nGeneratorStorageAvailability\nLineAvailability","category":"page"},{"location":"api/public/#PRASCore.Systems.SystemModel","page":"Public API Reference","title":"PRASCore.Systems.SystemModel","text":"SystemModel\n\nA SystemModel contains a representation of a power system to be studied with PRAS.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Simulations.assess","page":"Public API Reference","title":"PRASCore.Simulations.assess","text":"assess(system::SystemModel, method::SequentialMonteCarlo, resultspecs::ResultSpec...)\n\nRun a Sequential Monte Carlo simulation on a system using the method data and return resultspecs.\n\nArguments\n\nsystem::SystemModel: PRAS data structure\nmethod::SequentialMonteCarlo: method for PRAS analysis\nresultspecs::ResultSpec...: PRAS metric for metrics like Shortfall missing generation\n\nReturns\n\nresults::Tuple{Vararg{ResultAccumulator{SequentialMonteCarlo}}}: PRAS metric results\n\n\n\n\n\nassess(\n    sys::PSY.System,\n    aggregation::Type{AT},\n    method::PRASCore.SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...,\n) where {AT <: PSY.AggregationTopology}\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\naggregation::Type{AT}: Aggregation topology to use in translating to PRAS\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\nassess(\n    sys::PowerSystems.System,\n    template::RATemplate,\n    method::SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...\n) -> Any\n\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\ntemplate::RATemplate: PRAS problem template\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\nassess(\n    sys::PowerSystems.System,\n    method::SequentialMonteCarlo,\n    resultsspecs::PRASCore.Results.ResultSpec...\n) -> Any\n\n\nAnalyze resource adequacy using Monte Carlo simulation.\n\nUses default template with Area level aggregation.\n\nArguments\n\nsys::PSY.System: PowerSystems.jl system model\nmethod::PRASCore.SequentialMonteCarlo: Simulation method to use\nresultsspec::PRASCore.Results.ResultSpec...: Results to compute\n\nReturns\n\nTuple of results from resultsspec: default is (ShortfallResult,)\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PRASCore.Simulations.SequentialMonteCarlo","page":"Public API Reference","title":"PRASCore.Simulations.SequentialMonteCarlo","text":"SequentialMonteCarlo(;\n    samples::Int=10_000,\n    seed::Integer=rand(UInt64),\n    verbose::Bool=false,\n    threaded::Bool=true\n)\n\nSequential Monte Carlo simulation parameters for PRAS analysis\n\nIt it recommended that you fix the random seed for reproducibility.\n\nArguments\n\nsamples::Int=10_000: Number of samples\nseed::Integer=rand(UInt64): Random seed\nverbose::Bool=false: Print progress\nthreaded::Bool=true: Use multi-threading\n\nReturns\n\nSequentialMonteCarlo: PRAS simulation specification\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.Shortfall","page":"Public API Reference","title":"PRASCore.Results.Shortfall","text":"Shortfall\n\nThe Shortfall result specification reports expectation-based resource adequacy risk metrics such as EUE and LOLE, producing a ShortfallResult.\n\nA ShortfallResult can be directly indexed by a region name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating  the average unserved energy in that region and timestep. However, in most cases it's simpler to use EUE and LOLE constructors to directly retrieve standard risk metrics.\n\nExample:\n\nshortfall, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Shortfall())\n\nperiod = ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")\n\n# Unserved energy mean and standard deviation\nsf_mean, sf_std = shortfall[\"Region A\", period]\n\n# System-wide risk metrics\neue = EUE(shortfall)\nlole = LOLE(shortfall)\nneue = NEUE(shorfall)\n\n# Regional risk metrics\nregional_eue = EUE(shortfall, \"Region A\")\nregional_lole = LOLE(shortfall, \"Region A\")\nregional_neue = NEUE(shortfall, \"Region A\")\n\n# Period-specific risk metrics\nperiod_eue = EUE(shortfall, period)\nperiod_lolp = LOLE(shortfall, period)\n\n# Region- and period-specific risk metrics\nperiod_eue = EUE(shortfall, \"Region A\", period)\nperiod_lolp = LOLE(shortfall, \"Region A\", period)\n\nSee ShortfallSamples for recording sample-level shortfall results.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.Surplus","page":"Public API Reference","title":"PRASCore.Results.Surplus","text":"Surplus\n\nThe Surplus result specification reports unused generation and storage discharge capability of Regions, producing a SurplusResult.\n\nA SurplusResult can be indexed by region name and timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average unused capacity in that region and timestep.\n\nExample:\n\nsurplus, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Surplus())\n\nsurplus_mean, surplus_std =\n    surplus[\"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee SurplusSamples for sample-level surplus results.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.Flow","page":"Public API Reference","title":"PRASCore.Results.Flow","text":"Flow\n\nThe Flow result specification reports the estimated average flow across transmission Interfaces, producing a FlowResult.\n\nA FlowResult can be indexed by a directional Pair of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average net flow magnitude and direction relative to the given directed interface in that timestep. For a query of \"Region A\" => \"Region B\", if estimated average flow was from A to B, the reported value would be positive, while if average flow was in the reverse direction, from B to A, the value would be negative.\n\nExample:\n\nflows, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Flow())\n\nflow_mean, flow_std =\n    flows[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\nflow2_mean, flow2_std =\n    flows[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n@assert flow_mean == -flow2_mean\n\nSee FlowSamples for sample-level flow results.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.Utilization","page":"Public API Reference","title":"PRASCore.Results.Utilization","text":"Utilization\n\nThe Utilization result specification reports the estimated average absolute utilization of Interfaces, producing a UtilizationResult.\n\nWhereas Flow reports the average directional power transfer across an interface, Utilization reports the absolute value of flow relative to the interface's transfer capability (counting the effects of line outages). For example, a symmetrically-constrained interface which is fully congested with max power flowing in one direction in half of the samples, and the other direction in the remaining samples, would have an average flow of 0 MW, but an average utilization of 100%.\n\nA UtilizationResult can be indexed by a Pair of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average utilization of the interface. Given the absolute value nature of the outcome, results are independent of direction. Querying \"Region A\" => \"Region B\" will yield the same result as \"Region B\" => \"Region A\".\n\nExample:\n\nutils, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Utilization())\n\nutil_mean, util_std =\n    utils[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nutil2_mean, util2_std =\n    utils[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert util_mean == util2_mean\n\nSee UtilizationSamples for sample-level utilization results.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.StorageEnergy","page":"Public API Reference","title":"PRASCore.Results.StorageEnergy","text":"StorageEnergy\n\nThe StorageEnergy result specification reports the average state of charge of Storages, producing a StorageEnergyResult.\n\nA StorageEnergyResult can be indexed by storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given storage device in that timestep.\n\nExample:\n\nstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=1000), StorageEnergy())\n\nsoc_mean, soc_std =\n    storenergy[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee StorageEnergySamples for sample-level storage states of charge.\n\nSee GeneratorStorageEnergy for average generator-storage states of charge.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.GeneratorStorageEnergy","page":"Public API Reference","title":"PRASCore.Results.GeneratorStorageEnergy","text":"GeneratorStorageEnergy\n\nThe GeneratorStorageEnergy result specification reports the average state of charge of GeneratorStorages, producing a GeneratorStorageEnergyResult.\n\nA GeneratorStorageEnergyResult can be indexed by generator-storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given generator-storage device in that timestep.\n\nExample:\n\ngenstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=1000), GeneratorStorageEnergy())\n\nsoc_mean, soc_std =\n    genstorenergy[\"MyGeneratorStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee GeneratorStorageEnergySamples for sample-level generator-storage states of charge.\n\nSee StorageEnergy for average storage states of charge.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.LOLE","page":"Public API Reference","title":"PRASCore.Results.LOLE","text":"LOLE\n\nLOLE reports loss of load expectation over a particular time period and regional extent. When the reporting period is a single simulation timestep, the metric is equivalent to loss of load probability (LOLP).\n\nContains both the estimated value itself as well as the standard error of that estimate, which can be extracted with val and stderror, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.EUE","page":"Public API Reference","title":"PRASCore.Results.EUE","text":"EUE\n\nEUE reports expected unserved energy over a particular time period and regional extent.\n\nContains both the estimated value itself as well as the standard error of that estimate, which can be extracted with val and stderror, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.ShortfallSamples","page":"Public API Reference","title":"PRASCore.Results.ShortfallSamples","text":"ShortfallSamples\n\nThe ShortfallSamples result specification reports sample-level unserved energy outcomes, producing a ShortfallSamplesResult.\n\nA ShortfallSamplesResult can be directly indexed by a region name and a timestamp to retrieve a vector of sample-level unserved energy results in that region and timestep. EUE and LOLE constructors can also be used to retrieve standard risk metrics.\n\nExample:\n\nshortfall, =\n    assess(sys, SequentialMonteCarlo(samples=10), ShortfallSamples())\n\nperiod = ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")\n\nsamples = shortfall[\"Region A\", period]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\n# System-wide risk metrics\neue = EUE(shortfall)\nlole = LOLE(shortfall)\nneue = NEUE(shortfall)\n\n# Regional risk metrics\nregional_eue = EUE(shortfall, \"Region A\")\nregional_lole = LOLE(shortfall, \"Region A\")\nregional_neue = NEUE(shortfall, \"Region A\")\n\n# Period-specific risk metrics\nperiod_eue = EUE(shortfall, period)\nperiod_lolp = LOLE(shortfall, period)\n\n# Region- and period-specific risk metrics\nperiod_eue = EUE(shortfall, \"Region A\", period)\nperiod_lolp = LOLE(shortfall, \"Region A\", period)\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Shortfall for average shortfall outcomes when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.SurplusSamples","page":"Public API Reference","title":"PRASCore.Results.SurplusSamples","text":"SurplusSamples\n\nThe SurplusSamples result specification reports sample-level unused generation and storage discharge capability of Regions, producing a SurplusSamplesResult.\n\nA SurplusSamplesResult can be indexed by region name and timestamp to retrieve a vector of sample-level surplus values in that region and timestep.\n\nExample:\n\nsurplus, =\n    assess(sys, SequentialMonteCarlo(samples=10), SurplusSamples())\n\nsamples = surplus[\"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Surplus for estimated average surplus values when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.FlowSamples","page":"Public API Reference","title":"PRASCore.Results.FlowSamples","text":"FlowSamples\n\nThe FlowSamples result specification reports the sample-level magnitude and direction of power flows across Interfaces, producing a FlowSamplesResult.\n\nA FlowSamplesResult can be indexed by a directional Pair of region names and a timestamp to retrieve a vector of sample-level net flow magnitudes and directions relative to the given directed interface in that timestep. For a query of \"Region A\" => \"Region B\", if flow in one sample was from A to B, the reported value would be positive, while if flow was in the reverse direction, from B to A, the value would be negative.\n\nExample:\n\nflows, =\n    assess(sys, SequentialMonteCarlo(samples=10), FlowSamples())\n\nsamples = flows[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nsamples2 = flows[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples == -samples2\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Flow for estimated average flow results when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.UtilizationSamples","page":"Public API Reference","title":"PRASCore.Results.UtilizationSamples","text":"UtilizationSamples\n\nThe UtilizationSamples result specification reports the sample-level absolute utilization of Interfaces, producing a UtilizationSamplesResult.\n\nWhereas FlowSamples reports the directional power transfer across an interface, UtilizationSamples reports the absolute value of flow relative to the interface's transfer capability (counting the effects of line outages). For example, a 100 MW symmetrically-constrained interface which is fully congested may have a flow of +100 or -100 MW, but in both cases the utilization will be 100%. If a 50 MW line in the interface went on outage, flow may drop to +50 or -50 MW, but utilization would remain at 100%.\n\nA UtilizationSamplesResult can be indexed by a Pair of region names and a timestamp to retrieve a vector of sample-level utilizations of the interface in that timestep. Given the absolute value nature of the outcome, results are independent of direction. Querying \"Region A\" => \"Region B\" will yield the same result as \"Region B\" => \"Region A\".\n\nExample:\n\nutils, =\n    assess(sys, SequentialMonteCarlo(samples=10), UtilizationSamples())\n\nsamples =\n    utils[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nsamples2 =\n    utils[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples == samples2\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Utilization for sample-averaged utilization results when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.StorageEnergySamples","page":"Public API Reference","title":"PRASCore.Results.StorageEnergySamples","text":"StorageEnergySamples\n\nThe StorageEnergySamples result specification reports the sample-level state of charge of Storages, producing a StorageEnergySamplesResult.\n\nA StorageEnergySamplesResult can be indexed by storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.\n\nExample:\n\nstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=10), StorageEnergySamples())\n\nsamples = storenergy[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See StorageEnergy for estimated average storage state of charge when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.GeneratorStorageEnergySamples","page":"Public API Reference","title":"PRASCore.Results.GeneratorStorageEnergySamples","text":"GeneratorStorageEnergySamples\n\nThe GeneratorStorageEnergySamples result specification reports the sample-level state of charge of GeneratorStorages, producing a GeneratorStorageEnergySamplesResult.\n\nA GeneratorStorageEnergySamplesResult can be indexed by generator-storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.\n\nExample:\n\ngenstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageEnergySamples())\n\nsamples = genstorenergy[\"MyGeneratorStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See GeneratorStorageEnergy for estimated average generator-storage state of charge when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.GeneratorAvailability","page":"Public API Reference","title":"PRASCore.Results.GeneratorAvailability","text":"GeneratorAvailability\n\nThe GeneratorAvailability result specification reports the sample-level discrete availability of Generators, producing a GeneratorAvailabilityResult.\n\nA GeneratorAvailabilityResult can be indexed by generator name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\ngenavail, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorAvailability())\n\nsamples = genavail[\"MyGenerator123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.GeneratorStorageAvailability","page":"Public API Reference","title":"PRASCore.Results.GeneratorStorageAvailability","text":"GeneratorStorageAvailability\n\nThe GeneratorStorageAvailability result specification reports the sample-level discrete availability of GeneratorStorages, producing a GeneratorStorageAvailabilityResult.\n\nA GeneratorStorageAvailabilityResult can be indexed by generator-storage name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\ngenstoravail, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageAvailability())\n\nsamples = genstoravail[\"MyGenerator123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PRASCore.Results.LineAvailability","page":"Public API Reference","title":"PRASCore.Results.LineAvailability","text":"LineAvailability\n\nThe LineAvailability result specification reports the sample-level discrete availability of Lines, producing a LineAvailabilityResult.\n\nA LineAvailabilityResult can be indexed by line name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\nlineavail, =\n    assess(sys, SequentialMonteCarlo(samples=10), LineAvailability())\n\nsamples = lineavail[\"MyLine123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"}]
}
