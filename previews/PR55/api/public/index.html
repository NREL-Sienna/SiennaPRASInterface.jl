<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · SiennaPRASInterface.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SiennaPRASInterface.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../tutorials/intro_page/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Public API Reference</a></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/main/docs/src/api/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface" href="#SiennaPRASInterface"><code>SiennaPRASInterface</code></a> — <span class="docstring-category">Module</span></header><section><div><p>PowerSystems Interface for Probabilistic Resource Adequacy Studies (PRAS)</p><p><strong>Key Functions</strong></p><ul><li><a href="#SiennaPRASInterface.generate_pras_system"><code>generate_pras_system</code></a>: convert PSY to PRAS model</li><li><a href="#PRASCore.Simulations.assess"><code>assess</code></a>: assess PRAS model</li></ul><p><strong>Key PRAS Types</strong></p><ul><li><a href="#PRASCore.Systems.SystemModel"><code>SystemModel</code></a>: PRAS data structure</li><li><a href="#PRASCore.Simulations.SequentialMonteCarlo"><code>SequentialMonteCarlo</code></a>: method for PRAS analysis</li><li><a href="#PRASCore.Results.Shortfall"><code>Shortfall</code></a>: PRAS metric for missing generation</li><li><a href="#PRASCore.Results.LOLE"><code>LOLE</code></a>: PRAS metric for loss of load expectation</li><li><a href="#PRASCore.Results.EUE"><code>EUE</code></a>: PRAS metric for energy unserved expectation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/SiennaPRASInterface.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.generate_pras_system" href="#SiennaPRASInterface.generate_pras_system"><code>SiennaPRASInterface.generate_pras_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_pras_system(sys::PSY.System, aggregation; kwargs...)</code></pre><p>Sienna/Data PowerSystems.jl System is the input and an object of PRAS SystemModel is returned. ...</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Sienna/Data PowerSystems.jl System</li><li><code>aggregation&lt;:PSY.AggregationTopology</code>: &quot;PSY.Area&quot; (or) &quot;PSY.LoadZone&quot; {Optional}</li><li><code>lump_region_renewable_gens::Bool</code>: Whether to lumps PV and Wind generators in a region because usually these generators don&#39;t have FOR data {Optional}</li><li><code>export_location::String</code>: Export location of the .pras file ...</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">- `PRASCore.SystemModel`: PRAS SystemModel object</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_pras_system(psy_sys)
PRAS SystemModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/PowerSystems2PRAS.jl#L1-L25">source</a></section><section><div><pre><code class="nohighlight hljs">generate_pras_system(sys_location::String, aggregation; kwargs...)</code></pre><p>Generate a PRAS SystemModel from a Sienna/Data PowerSystems System JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>sys_location::String</code>: Location of the Sienna/Data PowerSystems System JSON file</li><li><code>aggregation::Type{AT}</code>: Aggregation topology type</li><li><code>lump_region_renewable_gens::Bool</code>: Lumping of region renewable generators</li><li><code>export_location::Union{Nothing, String}</code>: Export location of the .pras file</li></ul><p><strong>Returns</strong></p><ul><li><code>PRASCore.SystemModel</code>: PRAS SystemModel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/PowerSystems2PRAS.jl#L870-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Systems.SystemModel" href="#PRASCore.Systems.SystemModel"><code>PRASCore.Systems.SystemModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SystemModel</code></pre><p>A <code>SystemModel</code> contains a representation of a power system to be studied with PRAS.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Simulations.assess" href="#PRASCore.Simulations.assess"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assess(system::SystemModel, method::SequentialMonteCarlo, resultspecs::ResultSpec...)</code></pre><p>Run a Sequential Monte Carlo simulation on a <code>system</code> using the <code>method</code> data and return <code>resultspecs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>system::SystemModel</code>: PRAS data structure</li><li><code>method::SequentialMonteCarlo</code>: method for PRAS analysis</li><li><code>resultspecs::ResultSpec...</code>: PRAS metric for metrics like <a href="api/@ref"><code>Shortfall</code></a> missing generation</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Tuple{Vararg{ResultAccumulator{SequentialMonteCarlo}}}</code>: PRAS metric results</li></ul></div></section><section><div><pre><code class="nohighlight hljs">assess(
    sys::PSY.System,
    aggregation::Type{AT},
    method::PRASCore.SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...,
) where {AT &lt;: PSY.AggregationTopology}</code></pre><p>Estimate resource adequacy using Monte Carlo simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>aggregation::Type{AT}</code>: Aggregation topology to use in translating to PRAS</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="api/@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/SiennaPRASInterface.jl#L118-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Simulations.SequentialMonteCarlo" href="#PRASCore.Simulations.SequentialMonteCarlo"><code>PRASCore.Simulations.SequentialMonteCarlo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialMonteCarlo(;
    samples::Int=10_000,
    seed::Integer=rand(UInt64),
    verbose::Bool=false,
    threaded::Bool=true
)</code></pre><p>Sequential Monte Carlo simulation parameters for PRAS analysis</p><p>It it recommended that you fix the random seed for reproducibility.</p><p><strong>Arguments</strong></p><ul><li><code>samples::Int=10_000</code>: Number of samples</li><li><code>seed::Integer=rand(UInt64)</code>: Random seed</li><li><code>verbose::Bool=false</code>: Print progress</li><li><code>threaded::Bool=true</code>: Use multi-threading</li></ul><p><strong>Returns</strong></p><ul><li><code>SequentialMonteCarlo</code>: PRAS simulation specification</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.Shortfall" href="#PRASCore.Results.Shortfall"><code>PRASCore.Results.Shortfall</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Shortfall</code></pre><p>The <code>Shortfall</code> result specification reports expectation-based resource adequacy risk metrics such as EUE and LOLE, producing a <code>ShortfallResult</code>.</p><p>A <code>ShortfallResult</code> can be directly indexed by a region name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating  the average unserved energy in that region and timestep. However, in most cases it&#39;s simpler to use <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors to directly retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=1000), Shortfall())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

# Unserved energy mean and standard deviation
sf_mean, sf_std = shortfall[&quot;Region A&quot;, period]

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>See <a href="#PRASCore.Results.ShortfallSamples"><code>ShortfallSamples</code></a> for recording sample-level shortfall results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.Surplus" href="#PRASCore.Results.Surplus"><code>PRASCore.Results.Surplus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Surplus</code></pre><p>The <code>Surplus</code> result specification reports unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusResult</code>.</p><p>A <code>SurplusResult</code> can be indexed by region name and timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average unused capacity in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=1000), Surplus())

surplus_mean, surplus_std =
    surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.SurplusSamples"><code>SurplusSamples</code></a> for sample-level surplus results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.Flow" href="#PRASCore.Results.Flow"><code>PRASCore.Results.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flow</code></pre><p>The <code>Flow</code> result specification reports the estimated average flow across transmission <code>Interfaces</code>, producing a <code>FlowResult</code>.</p><p>A <code>FlowResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average net flow magnitude and direction relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if estimated average flow was from A to B, the reported value would be positive, while if average flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=1000), Flow())

flow_mean, flow_std =
    flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
flow2_mean, flow2_std =
    flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
@assert flow_mean == -flow2_mean</code></pre><p>See <a href="#PRASCore.Results.FlowSamples"><code>FlowSamples</code></a> for sample-level flow results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.Utilization" href="#PRASCore.Results.Utilization"><code>PRASCore.Results.Utilization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Utilization</code></pre><p>The <code>Utilization</code> result specification reports the estimated average absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationResult</code>.</p><p>Whereas <code>Flow</code> reports the average directional power transfer across an interface, <code>Utilization</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a symmetrically-constrained interface which is fully congested with max power flowing in one direction in half of the samples, and the other direction in the remaining samples, would have an average flow of 0 MW, but an average utilization of 100%.</p><p>A <code>UtilizationResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average utilization of the interface. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=1000), Utilization())

util_mean, util_std =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

util2_mean, util2_std =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert util_mean == util2_mean</code></pre><p>See <a href="#PRASCore.Results.UtilizationSamples"><code>UtilizationSamples</code></a> for sample-level utilization results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.StorageEnergy" href="#PRASCore.Results.StorageEnergy"><code>PRASCore.Results.StorageEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StorageEnergy</code></pre><p>The <code>StorageEnergy</code> result specification reports the average state of charge of <code>Storages</code>, producing a <code>StorageEnergyResult</code>.</p><p>A <code>StorageEnergyResult</code> can be indexed by storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), StorageEnergy())

soc_mean, soc_std =
    storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.StorageEnergySamples"><code>StorageEnergySamples</code></a> for sample-level storage states of charge.</p><p>See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for average generator-storage states of charge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergy" href="#PRASCore.Results.GeneratorStorageEnergy"><code>PRASCore.Results.GeneratorStorageEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergy</code></pre><p>The <code>GeneratorStorageEnergy</code> result specification reports the average state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergyResult</code>.</p><p>A <code>GeneratorStorageEnergyResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given generator-storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), GeneratorStorageEnergy())

soc_mean, soc_std =
    genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>GeneratorStorageEnergySamples</code></a> for sample-level generator-storage states of charge.</p><p>See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for average storage states of charge.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.LOLE" href="#PRASCore.Results.LOLE"><code>PRASCore.Results.LOLE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LOLE</code></pre><p><code>LOLE</code> reports loss of load expectation over a particular time period and regional extent. When the reporting period is a single simulation timestep, the metric is equivalent to loss of load probability (LOLP).</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.EUE" href="#PRASCore.Results.EUE"><code>PRASCore.Results.EUE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EUE</code></pre><p><code>EUE</code> reports expected unserved energy over a particular time period and regional extent.</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>val</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>stderror</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.generate_outage_profile" href="#SiennaPRASInterface.generate_outage_profile"><code>SiennaPRASInterface.generate_outage_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_outage_profile(pras_system,num_runs,psy_sys,num_scenarios,location)</code></pre><p>Process the assess results to get timeseries of generator status and include this timeseries data to the corresponding component in PSY System and exported using to_json method (serializing the PSY System).</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>pras_system::PRASCore.SystemModel</code>: PRAS System</li><li><code>num_runs::Int64</code>: Number of PRAS runs</li><li><code>psy_sys::PSY.System</code>: PSY System</li><li><code>num_scenarios::Int64</code>: Number of scenarios of user interest.</li><li><code>location::String</code>: Location to store outage profile. ...</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_outage_profile(results, pras_sys, psy_sys, 1)
PSY System exported using to_json method in InfrastructureSystems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/PRAS2PowerSystems.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.generate_csv_outage_profile" href="#SiennaPRASInterface.generate_csv_outage_profile"><code>SiennaPRASInterface.generate_csv_outage_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_outage_profile(pras_system,num_runs,psy_sys,num_scenarios,location)</code></pre><p>Process the assess results to get timeseries of generator status and include this timeseries data to the corresponding component in PSY System and exported using to_json method (serializing the PSY System).</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>pras_system::PRASCore.SystemModel</code>: PRAS System</li><li><code>num_runs::Int64</code>: Number of PRAS runs</li><li><code>psy_sys::PSY.System</code>: PSY System</li><li><code>num_scenarios::Int64</code>: Number of scenarios of user interest.</li><li><code>location::String</code>: Location to store outage profile. ...</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_outage_profile(results, pras_sys, psy_sys, 1)
PSY System exported using to_json method in InfrastructureSystems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/PRAS2PowerSystems.jl#L129-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.add_csv_time_series!" href="#SiennaPRASInterface.add_csv_time_series!"><code>SiennaPRASInterface.add_csv_time_series!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_csv_time_series!(
    sys_DA,
    sys_RT,
    outage_csv_location::String;
    days_of_interest::Union{Nothing, UnitRange}=nothing,
    add_scenario::Union{Nothing, Int}=nothing,
)</code></pre><p>Generates outage profile for two stage PowerSimulation and adds availability time series data to Generators in PSY System from CSV files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/util/sienna/add_csv_time_series_data.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.add_csv_time_series_single_stage!" href="#SiennaPRASInterface.add_csv_time_series_single_stage!"><code>SiennaPRASInterface.add_csv_time_series_single_stage!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_csv_time_series_single_stage!(
    sys_DA,
    outage_csv_location::String;
    days_of_interest::Union{Nothing, UnitRange}=nothing,
    add_scenario::Union{Nothing, Int}=nothing,
)</code></pre><p>Generates outage profile for single stage PowerSimulation and adds availability time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/util/sienna/add_csv_time_series_data.jl#L219-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SiennaPRASInterface.make_generator_outage_draws!" href="#SiennaPRASInterface.make_generator_outage_draws!"><code>SiennaPRASInterface.make_generator_outage_draws!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_generator_outage_draws!(
    sys,
    initial_time::Dates.DateTime=nothing,
    resolution::TIMEPERIOD=nothing,
    steps::Int=nothing,
    horizon::Int=nothing,
) where {TIMEPERIOD &lt;: Dates.TimePeriod}</code></pre><p>Adds availability time series to the generators in the system.</p><p>Main function to make generator outage draws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/3b545590ded2d9419906edc42f1fe177cb7d93e3/src/util/draws/sienna_draws.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.ShortfallSamples" href="#PRASCore.Results.ShortfallSamples"><code>PRASCore.Results.ShortfallSamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShortfallSamples</code></pre><p>The <code>ShortfallSamples</code> result specification reports sample-level unserved energy outcomes, producing a <code>ShortfallSamplesResult</code>.</p><p>A <code>ShortfallSamplesResult</code> can be directly indexed by a region name and a timestamp to retrieve a vector of sample-level unserved energy results in that region and timestep. <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors can also be used to retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=10), ShortfallSamples())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

samples = shortfall[&quot;Region A&quot;, period]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Shortfall"><code>Shortfall</code></a> for average shortfall outcomes when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.SurplusSamples" href="#PRASCore.Results.SurplusSamples"><code>PRASCore.Results.SurplusSamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurplusSamples</code></pre><p>The <code>SurplusSamples</code> result specification reports sample-level unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusSamplesResult</code>.</p><p>A <code>SurplusSamplesResult</code> can be indexed by region name and timestamp to retrieve a vector of sample-level surplus values in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=10), SurplusSamples())

samples = surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Surplus"><code>Surplus</code></a> for estimated average surplus values when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.FlowSamples" href="#PRASCore.Results.FlowSamples"><code>PRASCore.Results.FlowSamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlowSamples</code></pre><p>The <code>FlowSamples</code> result specification reports the sample-level magnitude and direction of power flows across <code>Interfaces</code>, producing a <code>FlowSamplesResult</code>.</p><p>A <code>FlowSamplesResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level net flow magnitudes and directions relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if flow in one sample was from A to B, the reported value would be positive, while if flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=10), FlowSamples())

samples = flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 = flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == -samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Flow"><code>Flow</code></a> for estimated average flow results when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.UtilizationSamples" href="#PRASCore.Results.UtilizationSamples"><code>PRASCore.Results.UtilizationSamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UtilizationSamples</code></pre><p>The <code>UtilizationSamples</code> result specification reports the sample-level absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationSamplesResult</code>.</p><p>Whereas <code>FlowSamples</code> reports the directional power transfer across an interface, <code>UtilizationSamples</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a 100 MW symmetrically-constrained interface which is fully congested may have a flow of +100 or -100 MW, but in both cases the utilization will be 100%. If a 50 MW line in the interface went on outage, flow may drop to +50 or -50 MW, but utilization would remain at 100%.</p><p>A <code>UtilizationSamplesResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level utilizations of the interface in that timestep. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=10), UtilizationSamples())

samples =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Utilization"><code>Utilization</code></a> for sample-averaged utilization results when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.StorageEnergySamples" href="#PRASCore.Results.StorageEnergySamples"><code>PRASCore.Results.StorageEnergySamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StorageEnergySamples</code></pre><p>The <code>StorageEnergySamples</code> result specification reports the sample-level state of charge of <code>Storages</code>, producing a <code>StorageEnergySamplesResult</code>.</p><p>A <code>StorageEnergySamplesResult</code> can be indexed by storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), StorageEnergySamples())

samples = storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for estimated average storage state of charge when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergySamples" href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>PRASCore.Results.GeneratorStorageEnergySamples</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergySamples</code></pre><p>The <code>GeneratorStorageEnergySamples</code> result specification reports the sample-level state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergySamplesResult</code>.</p><p>A <code>GeneratorStorageEnergySamplesResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageEnergySamples())

samples = genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for estimated average generator-storage state of charge when sample-level granularity isn&#39;t required.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.GeneratorAvailability" href="#PRASCore.Results.GeneratorAvailability"><code>PRASCore.Results.GeneratorAvailability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneratorAvailability</code></pre><p>The <code>GeneratorAvailability</code> result specification reports the sample-level discrete availability of <code>Generators</code>, producing a <code>GeneratorAvailabilityResult</code>.</p><p>A <code>GeneratorAvailabilityResult</code> can be indexed by generator name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genavail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorAvailability())

samples = genavail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageAvailability" href="#PRASCore.Results.GeneratorStorageAvailability"><code>PRASCore.Results.GeneratorStorageAvailability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageAvailability</code></pre><p>The <code>GeneratorStorageAvailability</code> result specification reports the sample-level discrete availability of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageAvailabilityResult</code>.</p><p>A <code>GeneratorStorageAvailabilityResult</code> can be indexed by generator-storage name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genstoravail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageAvailability())

samples = genstoravail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PRASCore.Results.LineAvailability" href="#PRASCore.Results.LineAvailability"><code>PRASCore.Results.LineAvailability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineAvailability</code></pre><p>The <code>LineAvailability</code> result specification reports the sample-level discrete availability of <code>Lines</code>, producing a <code>LineAvailabilityResult</code>.</p><p>A <code>LineAvailabilityResult</code> can be indexed by line name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">lineavail, =
    assess(sys, SequentialMonteCarlo(samples=10), LineAvailability())

samples = lineavail[&quot;MyLine123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/intro_page/">« Tutorials</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 16 January 2025 19:49">Thursday 16 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
