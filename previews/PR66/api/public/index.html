<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · github.com/NREL-Sienna/SiennaPRASInterface.jl</title><meta name="title" content="Public API Reference · github.com/NREL-Sienna/SiennaPRASInterface.jl"/><meta property="og:title" content="Public API Reference · github.com/NREL-Sienna/SiennaPRASInterface.jl"/><meta property="twitter:title" content="Public API Reference · github.com/NREL-Sienna/SiennaPRASInterface.jl"/><meta name="description" content="Documentation for github.com/NREL-Sienna/SiennaPRASInterface.jl."/><meta property="og:description" content="Documentation for github.com/NREL-Sienna/SiennaPRASInterface.jl."/><meta property="twitter:description" content="Documentation for github.com/NREL-Sienna/SiennaPRASInterface.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">github.com/NREL-Sienna/SiennaPRASInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../how_to_guides/how_do_i_add_outage_data/">How do I add outage data?</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/default_outage_values/">Default outage values</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Public API Reference</a><ul class="internal"><li><a class="tocitem" href="#PRAS-Documentation"><span>PRAS Documentation</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/main/docs/src/api/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.SiennaPRASInterface" href="#SiennaPRASInterface.SiennaPRASInterface"><code>SiennaPRASInterface.SiennaPRASInterface</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>PowerSystems Interface for Probabilistic Resource Adequacy Studies (PRAS)</p><p><strong>Key Functions</strong></p><ul><li><a href="#SiennaPRASInterface.generate_pras_system"><code>generate_pras_system</code></a>: convert PSY to PRAS model</li><li><a href="#PRASCore.Simulations.assess"><code>assess</code></a>: assess PRAS model</li></ul><p><strong>Key PRAS Types</strong></p><ul><li><a href="#PRASCore.Systems.SystemModel"><code>SystemModel</code></a>: PRAS data structure</li><li><a href="#PRASCore.Simulations.SequentialMonteCarlo"><code>SequentialMonteCarlo</code></a>: method for PRAS analysis</li><li><a href="#PRASCore.Results.Shortfall"><code>Shortfall</code></a>: PRAS metric for missing generation</li><li><a href="#PRASCore.Results.LOLE"><code>LOLE</code></a>: PRAS metric for loss of load expectation</li><li><a href="#PRASCore.Results.EUE"><code>EUE</code></a>: PRAS metric for energy unserved expectation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.DeviceRAModel" href="#SiennaPRASInterface.DeviceRAModel"><code>SiennaPRASInterface.DeviceRAModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeviceRAModel{D &lt;: PSY.Device, B &lt;: AbstractRAFormulation}</code></pre><p><strong>Arguments</strong></p><ul><li><p>D &lt;: PSY.Device: Device type</p><ul><li><code>formulation::SiennaPRASInterface.AbstractRAFormulation</code>: Formulation containing configuration</li></ul></li></ul><p>A DeviceRAModel, like a DeviceModel in PowerSimulations, assigns a type of Component to a specific formulation. Unlike Sienna, we put configuration information in the formulation itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L150-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.DeviceRAModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D}, Type{B}}} where {D&lt;:PowerSystems.Device, B&lt;:SiennaPRASInterface.AbstractRAFormulation}" href="#SiennaPRASInterface.DeviceRAModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D}, Type{B}}} where {D&lt;:PowerSystems.Device, B&lt;:SiennaPRASInterface.AbstractRAFormulation}"><code>SiennaPRASInterface.DeviceRAModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeviceRAModel(
    ::Type{D&lt;:PowerSystems.Device},
    ::Type{B&lt;:SiennaPRASInterface.AbstractRAFormulation};
    time_series_names,
    kwargs...
) -&gt; DeviceRAModel
</code></pre><p><strong>Arguments</strong></p><ul><li><code>::Type{D}</code>: Device type</li><li><code>::Type{B}</code>: Formulation type</li><li><code>time_series_names::Dict{Symbol, String}</code>: Mapping of time series <code>Symbol</code> to names</li><li><code>kwargs...</code>: Additional arguments to pass to the formulation constructor</li></ul><p>Keyword arguments in DeviceRAModel are passed to the formulation constructor.</p><p>You may also pass a <code>time_series_names</code> Dict to map time series <code>Symbol</code> to names.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">DeviceRAModel(
    PSY.Generator,
    GeneratorPRAS(max_active_power=&quot;max_active_power&quot;),
)</code></pre><pre><code class="language-julia hljs">DeviceRAModel(
    PSY.HydroEnergyReservoir,
    HydroEnergyReservoirPRAS;
    max_active_power=&quot;max_active_power&quot;,
    inflow=&quot;inflow&quot;,
    storage_capacity=&quot;storage_capacity&quot;,
)</code></pre><pre><code class="language-julia hljs">DeviceRAModel(
    PSY.HybridSystem,
    HybridSystemPRAS;
    time_series_names=Dict(:max_active_power=&quot;max_active_power&quot;),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L181-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.EnergyReservoirLossless" href="#SiennaPRASInterface.EnergyReservoirLossless"><code>SiennaPRASInterface.EnergyReservoirLossless</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EnergyReservoirLossless &lt;: StoragePRAS</code></pre><p>EnergyReservoirLossless is a storage formulation that does not lose energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.GeneratorPRAS" href="#SiennaPRASInterface.GeneratorPRAS"><code>SiennaPRASInterface.GeneratorPRAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorPRAS(; max_active_power, lump_renewable_generation) &lt;: AbstractRAFormulation</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>max_active_power::String</code>: Name of time series to use for max active power</p></li><li><p><code>lump_renewable_generation::Bool</code>: Whether to lump renewable generation to regions</p></li></ul><p>GeneratorPRAS produces generator entries in PRAS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.GeneratorStoragePRAS" href="#SiennaPRASInterface.GeneratorStoragePRAS"><code>SiennaPRASInterface.GeneratorStoragePRAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStoragePRAS &lt;: AbstractRAFormulation</code></pre><p>Objects in Sienna that behave like generator and storage are mapped to generatorstorage in PRAS.</p><p>To add a generator storage formulation, you must also add a <a href="../internal/#SiennaPRASInterface.assign_to_gen_stor_matrices!-Tuple{HybridSystemPRAS, PowerSystems.Device, SiennaPRASInterface.S2P_metadata, Vararg{Any, 5}}"><code>assign_to_gen_stor_matrices!</code></a> function.</p><ul><li><a href="#SiennaPRASInterface.HybridSystemPRAS"><code>HybridSystemPRAS</code></a></li><li><a href="#SiennaPRASInterface.HydroEnergyReservoirPRAS"><code>HydroEnergyReservoirPRAS</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.HybridSystemPRAS" href="#SiennaPRASInterface.HybridSystemPRAS"><code>SiennaPRASInterface.HybridSystemPRAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HybridSystemPRAS(; max_active_power) &lt;: GeneratorStoragePRAS</code></pre><p><strong>Arguments</strong></p><ul><li><code>max_active_power::String</code>: Name of time series to use for max active power</li></ul><p>HybridSystemPRAS produces generatorstorage entries in PRAS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.HydroEnergyReservoirPRAS" href="#SiennaPRASInterface.HydroEnergyReservoirPRAS"><code>SiennaPRASInterface.HydroEnergyReservoirPRAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HydroEnergyReservoirPRAS &lt;: GeneratorStoragePRAS</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>max_active_power::String</code>: Name of time series to use for max active power</p></li><li><p><code>inflow::String</code>: Name of time series to use for inflow</p></li><li><p><code>storage_capacity::String</code>: Name of time series to use for storage capacity</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.RATemplate" href="#SiennaPRASInterface.RATemplate"><code>SiennaPRASInterface.RATemplate</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Arguments</strong></p><ul><li><p><code>aggregation::Type{T} where T&lt;:PowerSystems.AggregationTopology</code>: Level of aggregation to use for PRAS regions</p></li><li><p><code>device_models::Array{DeviceRAModel}</code>: DeviceRAModels to translate components into PRAS</p></li></ul><p>The RATemplate contains all configuration necessary for building a PRAS Simulation from a PowerSystems.jl System.</p><p>Since PRAS is an area-based model, we provide a level of aggregation to apply.</p><p>PRAS models are processed in reverse order, with later models taking precedence.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">template = RATemplate(
    PSY.Area,
    [
        DeviceRAModel(
            PSY.Generator,
            GeneratorPRAS(max_active_power=&quot;max_active_power&quot;),
        ),
        DeviceRAModel(
            PSY.HydroEnergyReservoir,
            HydroEnergyReservoirPRAS(
                max_active_power=&quot;max_active_power&quot;,
                inflow=&quot;inflow&quot;,
                storage_capacity=&quot;storage_capacity&quot;,
            ),
        ),
    ],
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L249-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.StoragePRAS" href="#SiennaPRASInterface.StoragePRAS"><code>SiennaPRASInterface.StoragePRAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StoragePRAS &lt;: AbstractRAFormulation</code></pre><p>Objects in Sienna that behave like storage are mapped to storage in PRAS.</p><p>Subtypes must provide <a href="@ref"><code>assign_to_stor_matrices!</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.assess-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}" href="#PRASCore.Simulations.assess-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess(
    sys::PowerSystems.System,
    template::RATemplate,
    method::SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...
) -&gt; Any
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>template::RATemplate</code>: PRAS problem template</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L159-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.assess-Tuple{PowerSystems.System, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}" href="#PRASCore.Simulations.assess-Tuple{PowerSystems.System, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess(
    sys::PowerSystems.System,
    method::SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...
) -&gt; Any
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p>Uses default template with Area level aggregation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L185-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.assess-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}} where AT&lt;:PowerSystems.AggregationTopology" href="#PRASCore.Simulations.assess-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}} where AT&lt;:PowerSystems.AggregationTopology"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess(
    sys::PSY.System,
    aggregation::Type{AT},
    method::PRASCore.SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...,
) where {AT &lt;: PSY.AggregationTopology}</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>aggregation::Type{AT}</code>: Aggregation topology to use in translating to PRAS</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L128-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo}" href="#SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, RATemplate, SequentialMonteCarlo}"><code>SiennaPRASInterface.generate_outage_profile!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_outage_profile!(
    sys::PowerSystems.System,
    template::RATemplate,
    method::SequentialMonteCarlo
) -&gt; PowerSystems.System
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>template::RATemplate</code>: PRAS problem template</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li></ul><p><strong>Returns</strong></p><ul><li>PSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PRAS2PowerSystems.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, SequentialMonteCarlo}" href="#SiennaPRASInterface.generate_outage_profile!-Tuple{PowerSystems.System, SequentialMonteCarlo}"><code>SiennaPRASInterface.generate_outage_profile!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_outage_profile!(
    sys::PowerSystems.System,
    method::SequentialMonteCarlo
) -&gt; PowerSystems.System
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.</p><p>Uses default template with PSY.Area AggregationTopology.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">- PSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PRAS2PowerSystems.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_outage_profile!-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo}} where AT&lt;:PowerSystems.AggregationTopology" href="#SiennaPRASInterface.generate_outage_profile!-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}, SequentialMonteCarlo}} where AT&lt;:PowerSystems.AggregationTopology"><code>SiennaPRASInterface.generate_outage_profile!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_outage_profile!(
    sys::PSY.System,
    aggregation::Type{AT},
    method::PRASCore.SequentialMonteCarlo,
) where {AT &lt;: PSY.AggregationTopology, RM &lt;: PRASCore.Results.ReliabilityMetric}</code></pre><p>Analyze resource adequacy using Monte Carlo simulation and add the asset status from the worst sample to PSY.TimeSeriesForcedOutage of the component.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>aggregation::Type{AT}</code>: Aggregation topology to use in translating to PRAS</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li></ul><p><strong>Returns</strong></p><ul><li>PSY System with PSY.TimeSeriesForcedOutage for all components for which asset status is available</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PRAS2PowerSystems.jl#L29-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_pras_system" href="#SiennaPRASInterface.generate_pras_system"><code>SiennaPRASInterface.generate_pras_system</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_pras_system(
    sys::PowerSystems.System,
    template::RATemplate
) -&gt; SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T&lt;:Period}
generate_pras_system(
    sys::PowerSystems.System,
    template::RATemplate,
    export_location::Union{Nothing, String}
) -&gt; SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T&lt;:Period}
</code></pre><p>Use a RATemplate to create a PRAS system from a Sienna system.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Sienna PowerSystems System</li><li><code>template::RATemplate</code>: RATemplate</li><li><code>export_location::Union{Nothing, String}</code>: Export location for PRAS SystemModel</li></ul><p><strong>Returns</strong></p><ul><li><code>PRASCore.SystemModel</code>: PRAS SystemModel</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">generate_pras_system(sys, template)</code></pre><p>Note that the original system will only be set to NATURAL_UNITS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PowerSystems2PRAS.jl#L660-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}}, Tuple{PowerSystems.System, Type{AT}, Bool}, Tuple{PowerSystems.System, Type{AT}, Bool, Union{Nothing, String}}} where AT&lt;:PowerSystems.AggregationTopology" href="#SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{PowerSystems.System, Type{AT}}, Tuple{PowerSystems.System, Type{AT}, Bool}, Tuple{PowerSystems.System, Type{AT}, Bool, Union{Nothing, String}}} where AT&lt;:PowerSystems.AggregationTopology"><code>SiennaPRASInterface.generate_pras_system</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_pras_system(
    sys::PowerSystems.System,
    aggregation::Type{AT&lt;:PowerSystems.AggregationTopology}
) -&gt; SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T&lt;:Period}
generate_pras_system(
    sys::PowerSystems.System,
    aggregation::Type{AT&lt;:PowerSystems.AggregationTopology},
    lump_region_renewable_gens::Bool
) -&gt; SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T&lt;:Period}
generate_pras_system(
    sys::PowerSystems.System,
    aggregation::Type{AT&lt;:PowerSystems.AggregationTopology},
    lump_region_renewable_gens::Bool,
    export_location::Union{Nothing, String}
) -&gt; SystemModel{_A, _B, T, MW, MWh} where {_A, _B, T&lt;:Period}
</code></pre><p>Sienna/Data PowerSystems.jl System is the input and an object of PRAS SystemModel is returned. ...</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: Sienna/Data PowerSystems.jl System</li><li><code>aggregation&lt;:PSY.AggregationTopology</code>: &quot;PSY.Area&quot; (or) &quot;PSY.LoadZone&quot; {Optional}</li><li><code>lump_region_renewable_gens::Bool</code>: Whether to lumps PV and Wind generators in a region because usually these generators don&#39;t have FOR data {Optional}</li><li><code>export_location::String</code>: Export location of the .pras file ...</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">- `PRASCore.SystemModel`: PRAS SystemModel object</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generate_pras_system(psy_sys, PSY.Area)
PRAS SystemModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PowerSystems2PRAS.jl#L903-L927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{String, Type{AT}}, Tuple{String, Type{AT}, Any}, Tuple{String, Type{AT}, Any, Union{Nothing, String}}} where AT&lt;:PowerSystems.AggregationTopology" href="#SiennaPRASInterface.generate_pras_system-Union{Tuple{AT}, Tuple{String, Type{AT}}, Tuple{String, Type{AT}, Any}, Tuple{String, Type{AT}, Any, Union{Nothing, String}}} where AT&lt;:PowerSystems.AggregationTopology"><code>SiennaPRASInterface.generate_pras_system</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_pras_system(sys_location::String, aggregation; kwargs...)</code></pre><p>Generate a PRAS SystemModel from a Sienna/Data PowerSystems System JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>sys_location::String</code>: Location of the Sienna/Data PowerSystems System JSON file</li><li><code>aggregation::Type{AT}</code>: Aggregation topology type</li><li><code>lump_region_renewable_gens::Bool</code>: Lumping of region renewable generators</li><li><code>export_location::Union{Nothing, String}</code>: Export location of the .pras file</li></ul><p><strong>Returns</strong></p><ul><li><code>PRASCore.SystemModel</code>: PRAS SystemModel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/PowerSystems2PRAS.jl#L942-L957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.make_generator_outage_draws!-Union{Tuple{PowerSystems.System}, Tuple{TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64, Int64}} where TIMEPERIOD&lt;:Dates.TimePeriod" href="#SiennaPRASInterface.make_generator_outage_draws!-Union{Tuple{PowerSystems.System}, Tuple{TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64}, Tuple{PowerSystems.System, Dates.DateTime, TIMEPERIOD, Int64, Int64}} where TIMEPERIOD&lt;:Dates.TimePeriod"><code>SiennaPRASInterface.make_generator_outage_draws!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_generator_outage_draws!(
    sys,
    initial_time::Dates.DateTime=nothing,
    resolution::TIMEPERIOD=nothing,
    steps::Int=nothing,
    horizon::Int=nothing,
) where {TIMEPERIOD &lt;: Dates.TimePeriod}</code></pre><p>Adds availability time series to the generators in the system.</p><p>Main function to make generator outage draws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/util/draws/sienna_draws.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.set_device_model!-Union{Tuple{B}, Tuple{D}, Tuple{RATemplate, Type{D}, Type{B}}} where {D&lt;:DeviceRAModel, B&lt;:SiennaPRASInterface.AbstractRAFormulation}" href="#SiennaPRASInterface.set_device_model!-Union{Tuple{B}, Tuple{D}, Tuple{RATemplate, Type{D}, Type{B}}} where {D&lt;:DeviceRAModel, B&lt;:SiennaPRASInterface.AbstractRAFormulation}"><code>SiennaPRASInterface.set_device_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_device_model!(
    template::RATemplate,
    _::Type{D&lt;:DeviceRAModel},
    _::Type{B&lt;:SiennaPRASInterface.AbstractRAFormulation}
) -&gt; Vector{DeviceRAModel}
</code></pre><p><strong>Arguments</strong></p><ul><li><code>template::RATemplate</code>: Template to add device model to</li><li><code>::Type{D}</code>: Device type</li><li><code>::Type{B}</code>: Formulation type</li></ul><p>Adds a device model to a RATemplate by passing the type to a constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L318-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SiennaPRASInterface.set_device_model!-Union{Tuple{D}, Tuple{RATemplate, DeviceRAModel{D}}} where D" href="#SiennaPRASInterface.set_device_model!-Union{Tuple{D}, Tuple{RATemplate, DeviceRAModel{D}}} where D"><code>SiennaPRASInterface.set_device_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_device_model!(
    template::RATemplate,
    device_model::DeviceRAModel{D}
) -&gt; Vector{DeviceRAModel}
</code></pre><p><strong>Arguments</strong></p><ul><li><code>template::RATemplate</code>: Template to add device model to</li><li><code>device_model::DeviceRAModel{D}</code>: Device model to add</li></ul><p>Add a device model to a RATemplate. If an existing model already applies to the given device type, then a warning is issued. However, newer models will take precedence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/formulation_definitions.jl#L298-L308">source</a></section></article><h2 id="PRAS-Documentation"><a class="docs-heading-anchor" href="#PRAS-Documentation">PRAS Documentation</a><a id="PRAS-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#PRAS-Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.SystemModel" href="#PRASCore.Systems.SystemModel"><code>PRASCore.Systems.SystemModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemModel</code></pre><p>A <code>SystemModel</code> contains a representation of a power system to be studied with PRAS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Systems/SystemModel.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.assess" href="#PRASCore.Simulations.assess"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess(system::SystemModel, method::SequentialMonteCarlo, resultspecs::ResultSpec...)</code></pre><p>Run a Sequential Monte Carlo simulation on a <code>system</code> using the <code>method</code> data and return <code>resultspecs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>system::SystemModel</code>: PRAS data structure</li><li><code>method::SequentialMonteCarlo</code>: method for PRAS analysis</li><li><code>resultspecs::ResultSpec...</code>: PRAS metric for metrics like <a href="@ref"><code>Shortfall</code></a> missing generation</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Tuple{Vararg{ResultAccumulator{SequentialMonteCarlo}}}</code>: PRAS metric results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Simulations/Simulations.jl#L68-L83">source</a></section><section><div><pre><code class="language-julia hljs">assess(
    sys::PSY.System,
    aggregation::Type{AT},
    method::PRASCore.SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...,
) where {AT &lt;: PSY.AggregationTopology}</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>aggregation::Type{AT}</code>: Aggregation topology to use in translating to PRAS</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L128-L148">source</a></section><section><div><pre><code class="language-julia hljs">assess(
    sys::PowerSystems.System,
    template::RATemplate,
    method::SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...
) -&gt; Any
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>template::RATemplate</code>: PRAS problem template</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L159-L174">source</a></section><section><div><pre><code class="language-julia hljs">assess(
    sys::PowerSystems.System,
    method::SequentialMonteCarlo,
    resultsspecs::PRASCore.Results.ResultSpec...
) -&gt; Any
</code></pre><p>Analyze resource adequacy using Monte Carlo simulation.</p><p>Uses default template with Area level aggregation.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: PowerSystems.jl system model</li><li><code>method::PRASCore.SequentialMonteCarlo</code>: Simulation method to use</li><li><code>resultsspec::PRASCore.Results.ResultSpec...</code>: Results to compute</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of results from <code>resultsspec</code>: default is (<a href="@ref"><code>ShortfallResult</code></a>,)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/SiennaPRASInterface.jl/blob/86f2d5207038f2d7add0d3f6b1be5dadbdb494ae/src/SiennaPRASInterface.jl#L185-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.SequentialMonteCarlo" href="#PRASCore.Simulations.SequentialMonteCarlo"><code>PRASCore.Simulations.SequentialMonteCarlo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SequentialMonteCarlo(;
    samples::Int=10_000,
    seed::Integer=rand(UInt64),
    verbose::Bool=false,
    threaded::Bool=true
)</code></pre><p>Sequential Monte Carlo simulation parameters for PRAS analysis</p><p>It it recommended that you fix the random seed for reproducibility.</p><p><strong>Arguments</strong></p><ul><li><code>samples::Int=10_000</code>: Number of samples</li><li><code>seed::Integer=rand(UInt64)</code>: Random seed</li><li><code>verbose::Bool=false</code>: Print progress</li><li><code>threaded::Bool=true</code>: Use multi-threading</li></ul><p><strong>Returns</strong></p><ul><li><code>SequentialMonteCarlo</code>: PRAS simulation specification</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Simulations/Simulations.jl#L26-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Shortfall" href="#PRASCore.Results.Shortfall"><code>PRASCore.Results.Shortfall</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Shortfall</code></pre><p>The <code>Shortfall</code> result specification reports expectation-based resource adequacy risk metrics such as EUE and LOLE, producing a <code>ShortfallResult</code>.</p><p>A <code>ShortfallResult</code> can be directly indexed by a region name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating  the average unserved energy in that region and timestep. However, in most cases it&#39;s simpler to use <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors to directly retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=1000), Shortfall())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

# Unserved energy mean and standard deviation
sf_mean, sf_std = shortfall[&quot;Region A&quot;, period]

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>See <a href="#PRASCore.Results.ShortfallSamples"><code>ShortfallSamples</code></a> for recording sample-level shortfall results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/Shortfall.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Surplus" href="#PRASCore.Results.Surplus"><code>PRASCore.Results.Surplus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Surplus</code></pre><p>The <code>Surplus</code> result specification reports unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusResult</code>.</p><p>A <code>SurplusResult</code> can be indexed by region name and timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average unused capacity in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=1000), Surplus())

surplus_mean, surplus_std =
    surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.SurplusSamples"><code>SurplusSamples</code></a> for sample-level surplus results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/Surplus.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Flow" href="#PRASCore.Results.Flow"><code>PRASCore.Results.Flow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Flow</code></pre><p>The <code>Flow</code> result specification reports the estimated average flow across transmission <code>Interfaces</code>, producing a <code>FlowResult</code>.</p><p>A <code>FlowResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average net flow magnitude and direction relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if estimated average flow was from A to B, the reported value would be positive, while if average flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=1000), Flow())

flow_mean, flow_std =
    flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
flow2_mean, flow2_std =
    flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
@assert flow_mean == -flow2_mean</code></pre><p>See <a href="#PRASCore.Results.FlowSamples"><code>FlowSamples</code></a> for sample-level flow results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/Flow.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Utilization" href="#PRASCore.Results.Utilization"><code>PRASCore.Results.Utilization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Utilization</code></pre><p>The <code>Utilization</code> result specification reports the estimated average absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationResult</code>.</p><p>Whereas <code>Flow</code> reports the average directional power transfer across an interface, <code>Utilization</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a symmetrically-constrained interface which is fully congested with max power flowing in one direction in half of the samples, and the other direction in the remaining samples, would have an average flow of 0 MW, but an average utilization of 100%.</p><p>A <code>UtilizationResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average utilization of the interface. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=1000), Utilization())

util_mean, util_std =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

util2_mean, util2_std =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert util_mean == util2_mean</code></pre><p>See <a href="#PRASCore.Results.UtilizationSamples"><code>UtilizationSamples</code></a> for sample-level utilization results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/Utilization.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.StorageEnergy" href="#PRASCore.Results.StorageEnergy"><code>PRASCore.Results.StorageEnergy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StorageEnergy</code></pre><p>The <code>StorageEnergy</code> result specification reports the average state of charge of <code>Storages</code>, producing a <code>StorageEnergyResult</code>.</p><p>A <code>StorageEnergyResult</code> can be indexed by storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), StorageEnergy())

soc_mean, soc_std =
    storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.StorageEnergySamples"><code>StorageEnergySamples</code></a> for sample-level storage states of charge.</p><p>See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for average generator-storage states of charge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/StorageEnergy.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergy" href="#PRASCore.Results.GeneratorStorageEnergy"><code>PRASCore.Results.GeneratorStorageEnergy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergy</code></pre><p>The <code>GeneratorStorageEnergy</code> result specification reports the average state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergyResult</code>.</p><p>A <code>GeneratorStorageEnergyResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given generator-storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), GeneratorStorageEnergy())

soc_mean, soc_std =
    genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>GeneratorStorageEnergySamples</code></a> for sample-level generator-storage states of charge.</p><p>See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for average storage states of charge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/GeneratorStorageEnergy.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.LOLE" href="#PRASCore.Results.LOLE"><code>PRASCore.Results.LOLE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LOLE</code></pre><p><code>LOLE</code> reports loss of load expectation over a particular time period and regional extent. When the reporting period is a single simulation timestep, the metric is equivalent to loss of load probability (LOLP).</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/metrics.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.EUE" href="#PRASCore.Results.EUE"><code>PRASCore.Results.EUE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EUE</code></pre><p><code>EUE</code> reports expected unserved energy over a particular time period and regional extent.</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/metrics.jl#L103-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.ShortfallSamples" href="#PRASCore.Results.ShortfallSamples"><code>PRASCore.Results.ShortfallSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShortfallSamples</code></pre><p>The <code>ShortfallSamples</code> result specification reports sample-level unserved energy outcomes, producing a <code>ShortfallSamplesResult</code>.</p><p>A <code>ShortfallSamplesResult</code> can be directly indexed by a region name and a timestamp to retrieve a vector of sample-level unserved energy results in that region and timestep. <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors can also be used to retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=10), ShortfallSamples())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

samples = shortfall[&quot;Region A&quot;, period]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Shortfall"><code>Shortfall</code></a> for average shortfall outcomes when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/ShortfallSamples.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.SurplusSamples" href="#PRASCore.Results.SurplusSamples"><code>PRASCore.Results.SurplusSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurplusSamples</code></pre><p>The <code>SurplusSamples</code> result specification reports sample-level unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusSamplesResult</code>.</p><p>A <code>SurplusSamplesResult</code> can be indexed by region name and timestamp to retrieve a vector of sample-level surplus values in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=10), SurplusSamples())

samples = surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Surplus"><code>Surplus</code></a> for estimated average surplus values when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/SurplusSamples.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.FlowSamples" href="#PRASCore.Results.FlowSamples"><code>PRASCore.Results.FlowSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlowSamples</code></pre><p>The <code>FlowSamples</code> result specification reports the sample-level magnitude and direction of power flows across <code>Interfaces</code>, producing a <code>FlowSamplesResult</code>.</p><p>A <code>FlowSamplesResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level net flow magnitudes and directions relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if flow in one sample was from A to B, the reported value would be positive, while if flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=10), FlowSamples())

samples = flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 = flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == -samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Flow"><code>Flow</code></a> for estimated average flow results when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/FlowSamples.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.UtilizationSamples" href="#PRASCore.Results.UtilizationSamples"><code>PRASCore.Results.UtilizationSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UtilizationSamples</code></pre><p>The <code>UtilizationSamples</code> result specification reports the sample-level absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationSamplesResult</code>.</p><p>Whereas <code>FlowSamples</code> reports the directional power transfer across an interface, <code>UtilizationSamples</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a 100 MW symmetrically-constrained interface which is fully congested may have a flow of +100 or -100 MW, but in both cases the utilization will be 100%. If a 50 MW line in the interface went on outage, flow may drop to +50 or -50 MW, but utilization would remain at 100%.</p><p>A <code>UtilizationSamplesResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level utilizations of the interface in that timestep. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=10), UtilizationSamples())

samples =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.Utilization"><code>Utilization</code></a> for sample-averaged utilization results when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/UtilizationSamples.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.StorageEnergySamples" href="#PRASCore.Results.StorageEnergySamples"><code>PRASCore.Results.StorageEnergySamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StorageEnergySamples</code></pre><p>The <code>StorageEnergySamples</code> result specification reports the sample-level state of charge of <code>Storages</code>, producing a <code>StorageEnergySamplesResult</code>.</p><p>A <code>StorageEnergySamplesResult</code> can be indexed by storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), StorageEnergySamples())

samples = storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for estimated average storage state of charge when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/StorageEnergySamples.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergySamples" href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>PRASCore.Results.GeneratorStorageEnergySamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergySamples</code></pre><p>The <code>GeneratorStorageEnergySamples</code> result specification reports the sample-level state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergySamplesResult</code>.</p><p>A <code>GeneratorStorageEnergySamplesResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageEnergySamples())

samples = genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for estimated average generator-storage state of charge when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/GeneratorStorageEnergySamples.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorAvailability" href="#PRASCore.Results.GeneratorAvailability"><code>PRASCore.Results.GeneratorAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorAvailability</code></pre><p>The <code>GeneratorAvailability</code> result specification reports the sample-level discrete availability of <code>Generators</code>, producing a <code>GeneratorAvailabilityResult</code>.</p><p>A <code>GeneratorAvailabilityResult</code> can be indexed by generator name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genavail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorAvailability())

samples = genavail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/GeneratorAvailability.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageAvailability" href="#PRASCore.Results.GeneratorStorageAvailability"><code>PRASCore.Results.GeneratorStorageAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageAvailability</code></pre><p>The <code>GeneratorStorageAvailability</code> result specification reports the sample-level discrete availability of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageAvailabilityResult</code>.</p><p>A <code>GeneratorStorageAvailabilityResult</code> can be indexed by generator-storage name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genstoravail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageAvailability())

samples = genstoravail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/GeneratorStorageAvailability.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.LineAvailability" href="#PRASCore.Results.LineAvailability"><code>PRASCore.Results.LineAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineAvailability</code></pre><p>The <code>LineAvailability</code> result specification reports the sample-level discrete availability of <code>Lines</code>, producing a <code>LineAvailabilityResult</code>.</p><p>A <code>LineAvailabilityResult</code> can be indexed by line name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">lineavail, =
    assess(sys, SequentialMonteCarlo(samples=10), LineAvailability())

samples = lineavail[&quot;MyLine123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/v0.7.0/src/Results/LineAvailability.jl#L1-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../explanations/default_outage_values/">« Default outage values</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 25 February 2025 18:55">Tuesday 25 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
